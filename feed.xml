<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Park Doyeon</title>
  
  
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://parkdoyeon.github.io/"/>
  <updated>2020-02-24T14:44:18.426Z</updated>
  <id>https://parkdoyeon.github.io/</id>
  
  <author>
    <name>Park Doyeon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Elixir와 함수형 프로그래밍</title>
    <link href="https://parkdoyeon.github.io/elixir/elixir-2020-02-03-elixir-functional/"/>
    <id>https://parkdoyeon.github.io/elixir/elixir-2020-02-03-elixir-functional/</id>
    <published>2020-02-03T14:37:20.000Z</published>
    <updated>2020-02-24T14:44:18.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OOP-has-methods-FP-has-functions"><a href="#OOP-has-methods-FP-has-functions" class="headerlink" title="OOP has methods, FP has functions"></a>OOP has methods, FP has functions</h1><p>객체 지향적인 프로그래밍은 클래스 인스턴스 메소드를 사용하여 상태변경을 하게되는데, 몇가지 단점이 있다.</p><ol><li>상태와 메소드간의 강한결합(coupling)이 발생한다. 실제세계에서는 객체지향적인 메소드 사용보다 서브클래싱을 하여 메소드를 공유하는 경우가 더 빈번하다.</li><li>역할에 대한 혼란을 불러일으킨다. 메소드의 다른 역할이 필요해질 때 클래스 확장이나 서브클래싱을 사용하는데, 이 또한 강항 결합을 야기한다.</li><li>동시성 환경에서 오브젝트의 상태값을 예기치 못하게 변형할 수 있다.</li></ol><h1 id="Functions-and-State"><a href="#Functions-and-State" class="headerlink" title="Functions and State"></a>Functions and State</h1><p>함수형 프로그래밍은 본래의 상태값을 절대 변경하지 않는다. 상태는 변형되지 않으며, 오직 또 다른 새로운 상태를 반환할 뿐이다. 때문에 함수는 pure하다고 말할 수 있다. 다시말해, 함수는 쉽게 조합되거나 재사용될 수 있다.</p><p>엘릭서의 주된 도구는 함수의 조합(파이프 오퍼레이터의 사용 등의…)이나 패턴매칭(다른 파라미터를 갖는 같은 이름의 여러의 함수를 작성하는 것)이다. 파이프 오퍼레이터와 패턴매칭 조합을 통해 자연스럽게 다음 연산 수행되기 때문에, 조건문을 최대한 사용하지 않는 방향에서 코드작성이 가능하다. 조건문이 많아지면 코드작성이 어렵고 가독성이 떨어지므로, 조건문을 작성하지 않음으로서 좋은 설계가 가능하다. 예를들어, 아래와 같이 조건문을 사용하지 않고도 함수 파라미터가 같은 두개의 값을 인자로 취했는지 아닌지 판단할수도 있다.</p><pre><code>@doc “&quot;&quot;a function that takes two parameters.It should return `true` if the parameters are the same, `false` others.You aren&#39;t allowed to use any conditional logic, so you&#39;ll have to rely on pattern matching.“&quot;&quot;def equal(a, a), do: truedef equal(_, _), do: false</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OOP-has-methods-FP-has-functions&quot;&gt;&lt;a href=&quot;#OOP-has-methods-FP-has-functions&quot; class=&quot;headerlink&quot; title=&quot;OOP has methods, FP has func
      
    
    </summary>
    
      <category term="Elixir" scheme="https://parkdoyeon.github.io/elixir/"/>
    
    
      <category term="elixir" scheme="https://parkdoyeon.github.io/tags/elixir/"/>
    
      <category term="functional" scheme="https://parkdoyeon.github.io/tags/functional/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS에서 asdf을 통한 언어 버전관리 + elixir 설치하기</title>
    <link href="https://parkdoyeon.github.io/dev-env/dev-env-2020-02-01-asdf/"/>
    <id>https://parkdoyeon.github.io/dev-env/dev-env-2020-02-01-asdf/</id>
    <published>2020-02-01T04:22:22.000Z</published>
    <updated>2020-02-23T01:34:13.470Z</updated>
    
    <content type="html"><![CDATA[<p>asdf는 개발환경에서 언어 사용 버전을 관리할 수 있도록 하는 오픈소스이다. 솔루션마다 적용되는 언어가 다를 경우 개발환경에서 커맨드 라인을 통해 손쉽게 현재 사용되는 언어의 버전 포인터를 바꿔줄 수 있다. 설치나 사용방법이 간단하고, <a href="https://asdf-vm.com/#/core-manage-asdf-vm" rel="external nofollow noopener noreferrer" target="_blank">asdf 공식문서</a>에도 설명이 잘 나와있지만 할때마다 elixir와 erlang 세팅을 할때 한번씩 빼먹는게 있어서 순서대로 정리해놓기로 했다. 내가 사용하는 환경은 Mac OS Catalina 이상에 패키지 매니저로 homebrew가 설치되어있다.</p><ol><li><p>asdf설치하기 (Mac OS 중심으로)<br>Homebrew를 통해 asdf을 설치한다.</p><pre><code class="shell">$ brew install asdf</code></pre><p>Mac OS Catalina 버전에서 다음과 같이 쉘에 입력한다. </p><pre><code class="shell">$ echo -e &#39;\n. $HOME/.asdf/asdf.sh&#39; &gt;&gt; ~/.zprofile</code></pre><p>미만 버전에서는 아래를 입력하면 된다.</p><pre><code class="shell">$ echo -e &#39;\n. $HOME/.asdf/asdf.sh&#39; &gt;&gt; ~/.bash_profile$ echo -e &#39;\n. $HOME/.asdf/completions/asdf.bash&#39; &gt;&gt; ~/.bash_profile</code></pre></li><li><p>플러그인 추가하기<br>각 버전을 관리할 수 있도록 플러그인을 추가한다</p><pre><code class="shell">$ asdf plugin-add erlang$ asdf plugin-add elixir</code></pre></li><li><p>erlang 설치하기<br>이제 언어를 설치하면 되는데, elixir는 erlang VM환경에서 동작하므로 <a href="https://github.com/asdf-vm/asdf-erlang" target="_blank" rel="noopener">erlang</a>이 설치되어 있어야 한다. 그리고 erlang을 설치를 위해서는 build tool을 설치해야 한다. Mac OS의 경우 이미 있을 확률이 높다.</p><pre><code class="shell">$ brew install autoconf</code></pre><p>확인이 되었다면 이제 erlang OTP를 다운로드하자. 나는 현재 최신버전인 22.2를 받았다. 다운로드가 완료되면 다운로드 받은 erlang언어 버전중에 사용하고싶은 버전을 global하게 지정해주면 된다. local로 지정하면 로그인한 시스템 유저만 사용할 수 있다.</p><pre><code class="shell">$ asdf install erlang 22.2$ asdf global erlang 22.2</code></pre></li><li><p>elixir 설치하기<br>erlang이 잘 설치되었다면 이제 <a href="https://github.com/asdf-vm/asdf-elixir" target="_blank" rel="noopener">엘릭서</a> 설치를 하면 된다.</p><pre><code class="shell">$ asdf install elixir 1.10$ asdf global elixir 1.10</code></pre><p>설치가 완료되면 아래와 같은 명령어를 통해 리스폰스가 잘 나오는지 확인해보자.</p><pre><code class="shell">$ elixir -v$ iex # elixir의 인터렉티브 쉘</code></pre></li><li><p>asdf 사용 현황 보기</p><pre><code class="shell">$ asdf currentelixir         1.10     (set by /Users/doyeon/.tool-versions)erlang         22.2     (set by /Users/doyeon/.tool-versions)</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;asdf는 개발환경에서 언어 사용 버전을 관리할 수 있도록 하는 오픈소스이다. 솔루션마다 적용되는 언어가 다를 경우 개발환경에서 커맨드 라인을 통해 손쉽게 현재 사용되는 언어의 버전 포인터를 바꿔줄 수 있다. 설치나 사용방법이 간단하고, &lt;a h
      
    
    </summary>
    
      <category term="Dev-Env" scheme="https://parkdoyeon.github.io/dev-env/"/>
    
    
      <category term="linux" scheme="https://parkdoyeon.github.io/tags/linux/"/>
    
      <category term="asdf" scheme="https://parkdoyeon.github.io/tags/asdf/"/>
    
  </entry>
  
  <entry>
    <title>Programming Elixir 6 - 문자열, 제어흐름</title>
    <link href="https://parkdoyeon.github.io/elixir/elixir-2020-01-30-elixir-basic-string/"/>
    <id>https://parkdoyeon.github.io/elixir/elixir-2020-01-30-elixir-basic-string/</id>
    <published>2020-01-30T02:02:34.000Z</published>
    <updated>2020-02-23T01:34:13.471Z</updated>
    
    <content type="html"><![CDATA[<h3 id="문자열"><a href="#문자열" class="headerlink" title="문자열"></a>문자열</h3><h4 id="Sigils-symbols-with-magical-power"><a href="#Sigils-symbols-with-magical-power" class="headerlink" title="Sigils ( symbols with magical power )"></a>Sigils ( symbols with magical power )</h4><p>물결로 시작하는 접두어를 sigil로 부른다</p><p>~C A character list with no escaping or interpolation<br>~c A character list, escaped and interpolated just like a single-quoted string<br>~D A Date in the format yyyy-mm-dd<br>~N A naive (raw) DateTime in the format yyyy-mm-dd hh:mm:ss[.ddd]<br>~R A regular expression with no escaping or interpolation<br>~r A regular expression, escaped and interpolated<br>~S A string with no escaping or interpolation<br>~s A string, escaped and interpolated just like a double-quoted string<br>~T A Time in the format hh:mm:ss[.dddd]<br>~W A list of whitespace-delimited words, with no escaping or interpolation ~w A list of whitespace-delimited words, with escaping and interpolation</p><p>sigil안에서 구분자(delimiter, (, [, {, &lt;)는 닫히지 않으면 이스케이프가 필요 없다.</p><h4 id="Single-quotations"><a href="#Single-quotations" class="headerlink" title="Single quotations"></a>Single quotations</h4><p>엘릭서에서 작은 따옴표 안에 문자는 캐릭터 리스트로 판단한다.</p><pre><code>iex&gt; ‘cat’‘cat&#39;iex&gt; [67, 65, 84]‘CAT&#39;iex&gt; [67, 65, 84, 101][67, 65, 84, 101]</code></pre><pre><code>iex&gt; str = ‘wombat&#39;‘wombat&#39;iex&gt; :io.format &quot;~w~n&quot;, [ str ] [119,111,109,98,97,116]:okiex&gt; List.to_tuple str{119, 111, 109, 98, 97, 116}iex&gt; str ++ [0][119, 111, 109, 98, 97, 116, 0]</code></pre><p>~n은 새줄 바꾸기를 의미한다.</p><p>~w은 언랭 언어로 스트링을 표기하는 것을 강제하는 것으로, 언랭 내에서 해당 표현이 불가능하면 그냥 반환된다.</p><pre><code>iex(12)&gt; &#39;∂x/∂y&#39;[8706, 120, 47, 8706, 121]iex(13)&gt; ~w&#39;∂x/∂y&#39; [&quot;∂x/∂y”]</code></pre><h4 id="Binaries"><a href="#Binaries" class="headerlink" title="Binaries"></a>Binaries</h4><p>바이너리는 &lt;&lt;&gt;&gt;안에 담긴 0부터 255까지의 연속된 숫자 리스트이다.<br>바이너리 안에 integer, float값을 담을 수 있다.</p><h4 id="Double-Quoted-Strings-Are-Binaries"><a href="#Double-Quoted-Strings-Are-Binaries" class="headerlink" title="Double-Quoted Strings Are Binaries"></a>Double-Quoted Strings Are Binaries</h4><p>single quotation으로 감싼 문자열은 리스트라면,<br>double quotation으로 감싸진 string은 utf-8인코딩된 일련의 바이트 데이터다.<br>이렇게 정의하면 합리적인데, 다음과 같은 이유에서이다.</p><p>첫째, 반드시 글자별로 다른 메모리값을 가질 수 있어 메모리 사용이 합리적이다.<br>둘째, 리스트를 다루는 방식으로 문자열을 조작할 필요가 없다. 접근 방식이 편리함.</p><p>문자열 데이터를 list 모듈에서 head-tail 구조로 분리할 수도 있는데.<br>이 경우 아래와 같이 바이너리 바이너리데이터 형식을 빌려서 분리할 수 있다.</p><pre><code>defmodule Utf8 do  def each(str, func) when is_binary(str), do: _each(str, func(  defp _each(&lt;&lt; head :: utf8, tail :: binary &gt;&gt;, func) do    func.(head)    _each(tail, func)  end  defp _each(&lt;&lt;&gt;&gt;, _func), do []end</code></pre><h3 id="제어흐름"><a href="#제어흐름" class="headerlink" title="제어흐름"></a>제어흐름</h3><p>제어문을 사용하는 것보다 함수로 처리하는 것을 더 권장.<br>코드가 더 간결하고 핵심적일 수 있기 때문.</p><p>Cond vs Case<br>cond는 여러 조건 체크가 필요한 경우 사용, case의 경우 패턴 매칭되는 요소를 찾을 때 사용</p><p>Exception<br>사용자 정의 예외 클래스의 경우 반드시 message를 구현해야 한다.<br>예외가 절대 발생하면 안되는 경우 별도로 예외처리를 별도로 하지 않지만,<br>그렇지 않다면 함수 끝에 느낌표를 넣으면 예외가 raise 되며, 유의미한 예외일 것이라는 관습적인 의미를 갖는다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;문자열&quot;&gt;&lt;a href=&quot;#문자열&quot; class=&quot;headerlink&quot; title=&quot;문자열&quot;&gt;&lt;/a&gt;문자열&lt;/h3&gt;&lt;h4 id=&quot;Sigils-symbols-with-magical-power&quot;&gt;&lt;a href=&quot;#Sigils-symbols-w
      
    
    </summary>
    
      <category term="Elixir" scheme="https://parkdoyeon.github.io/elixir/"/>
    
    
      <category term="string" scheme="https://parkdoyeon.github.io/tags/string/"/>
    
      <category term="elixir" scheme="https://parkdoyeon.github.io/tags/elixir/"/>
    
      <category term="control" scheme="https://parkdoyeon.github.io/tags/control/"/>
    
  </entry>
  
  <entry>
    <title>Programming Elixir 5 - 콜렉션 처리</title>
    <link href="https://parkdoyeon.github.io/elixir/elixir-2020-01-29-elixir-basic-collections/"/>
    <id>https://parkdoyeon.github.io/elixir/elixir-2020-01-29-elixir-basic-collections/</id>
    <published>2020-01-29T02:01:04.000Z</published>
    <updated>2020-02-23T01:34:13.471Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h3><p>Enum은 엘릭서의 모든 콜렉션 타입을 다루는 workhorse이다.<br>그러나 데이터 변환작업시 메모리에 중간 결과물을 포함한 모든 콜렉션 데이터를 올려놓기 때문에 lazy하게 동작하도록 하려면 Stream을 사용해야한다.<br>Stream은 스트림간의 모든 함수와 호환된다. 따라서 Stream은 Composable하다.</p><pre><code>IO.puts File.open!(“/usr/share/dict/words”)             |&gt; IO.stream(:line)             |&gt; Enum.max_by(&amp;String.length/1)# 위 코드의 shortcut코드IO.puts File.stream!(“/usr/share/dict/words”)             |&gt; Enum.max_by(&amp;String.length/1)# Stream을 사용한 구현은 중간 storage가 없는 대신 두배 이상 느리다는 단점이 있지만,# 데이터가 도달하면 바로바로 처리된다는 장점이 있다.# 가령 Enum으로만 구현한 경우 연속된 스트림라인이 늦게 도달했을 때 처리가 훨씬 더 오래걸릴 수 있다.</code></pre><h3 id="Collectable-Protocol"><a href="#Collectable-Protocol" class="headerlink" title="Collectable Protocol"></a>Collectable Protocol</h3><p>Enumerable Protocol은 타입 안의 요소를 순회하는 것이라면, Collectable은 반대의 개념으로 요소를 더해서 Collection을 빌드한다.<br>그러나 모든 콜렉션이 collectable한것은 아니다. Range 타입의 경우 요소 추가가 불가능 하며, Enum을 통한 Collectable 타입의 전환을 통해서 요소 추가가 가능하다. 이때, 이미 데이터가 있는 리스트와 병합되는 경우 range가 리스트 tail에 붙는다</p><pre><code>iex&gt; Enum.into 1..5, [100, 101][100, 101, 1, 2, 3, 4, 5]</code></pre><h3 id="Comprehension-Works-on-Bits-Too"><a href="#Comprehension-Works-on-Bits-Too" class="headerlink" title="Comprehension Works on Bits, Too"></a>Comprehension Works on Bits, Too</h3><pre><code>iex&gt; for &lt;&lt; &lt;&lt; b1::size(2), b2::size(3), b3::size(3) &gt;&gt; &lt;- “hello” &gt;&gt; , do: “0#{b1}#{b2}#{b3}”[&quot;0150&quot;, &quot;0145&quot;, &quot;0154&quot;, &quot;0154&quot;, &quot;0157”]</code></pre><p>여기서 &lt;&lt;&gt;&gt;은 바이너리를 가리킨다</p><h3 id="Moving-Past-Divinity"><a href="#Moving-Past-Divinity" class="headerlink" title="Moving Past Divinity"></a>Moving Past Divinity</h3><p>엘릭서를 효율적으로 학습하는 과정의 일부는 재귀와 순회를 적재적소에 사용하는 것을 고민하는 것이다.<br>가능하면 순회를 사용할 것을 권장한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Enum&quot;&gt;&lt;a href=&quot;#Enum&quot; class=&quot;headerlink&quot; title=&quot;Enum&quot;&gt;&lt;/a&gt;Enum&lt;/h3&gt;&lt;p&gt;Enum은 엘릭서의 모든 콜렉션 타입을 다루는 workhorse이다.&lt;br&gt;그러나 데이터 변환작업시 메모리에 중
      
    
    </summary>
    
      <category term="Elixir" scheme="https://parkdoyeon.github.io/elixir/"/>
    
    
      <category term="enum" scheme="https://parkdoyeon.github.io/tags/enum/"/>
    
      <category term="collection" scheme="https://parkdoyeon.github.io/tags/collection/"/>
    
      <category term="elixir" scheme="https://parkdoyeon.github.io/tags/elixir/"/>
    
  </entry>
  
  <entry>
    <title>Programming Elixir 4 - 타입과 모듈</title>
    <link href="https://parkdoyeon.github.io/elixir/elixir-2020-01-28-elixir-basic-typeandmodule/"/>
    <id>https://parkdoyeon.github.io/elixir/elixir-2020-01-28-elixir-basic-typeandmodule/</id>
    <published>2020-01-28T01:59:24.000Z</published>
    <updated>2020-02-23T01:36:35.772Z</updated>
    
    <content type="html"><![CDATA[<h3 id="리스트와-재귀"><a href="#리스트와-재귀" class="headerlink" title="리스트와 재귀"></a>리스트와 재귀</h3><h4 id="Heads-and-Tails"><a href="#Heads-and-Tails" class="headerlink" title="Heads and Tails"></a>Heads and Tails</h4><p>엘릭서는 join operator인 파이프 연산자로 머리와 나머지(tail)를 나눌 수 있다.<br>파이프 연산자와 재귀를 통해 길이 함수를 간단하게 구현할 수 있다.</p><pre><code>defmodule MyList do  def len([]), do: 0  def len([_head|tail]), do: 1 + len(tail)#head는 함수내에서 사용하는 일이 없으므로 컴파일시 경고를 띄우지않게 언더스코어를 넣는다.</code></pre><h4 id="문자열과-리스트"><a href="#문자열과-리스트" class="headerlink" title="문자열과 리스트"></a>문자열과 리스트</h4><p>엘릭서에서 문자열은 우리가 알고있는 일련의 단어들의 조합과 쿼테이션마크이면서,<br>리스트로 표기된 코드포인트의 값들이다. 후자의 경우 iEX에서 ‘리스트의 모든 값이 문자열로 표현가능한지’ 여부에 따라 구분한다. (heuristically; trial and error)</p><h3 id="다른-타입들"><a href="#다른-타입들" class="headerlink" title="다른 타입들"></a>다른 타입들</h3><h4 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h4><p>모듈의 이름이 곧 맵타입이 됨. 딕셔너리 기능이 없으므로 키값이 반드시 아톰이어야 한다.<br>구조체는 구조체에 특정한 행위를 정의하기위해 모듈 안에 정의한다.<br>구조체 안에 구조체를 넣는 Nested Structs 구현이 가능하다. Nested Struct의 접근자(Nested Accessor)는 기본적으로 컴파일 타임에 동작하는 매크로인데, 컴파일 타임에 동작하면 static하게 기능할 수 밖에 없으므로 다이나믹하게  </p><h3 id="엘릭서에서의-타입이란"><a href="#엘릭서에서의-타입이란" class="headerlink" title="엘릭서에서의 타입이란?"></a>엘릭서에서의 타입이란?</h3><p>primitive type vs functionality of module<br>In my mind, there’s a difference between the primitive list and the functional- ity of the List module. The primitive list is an implementation, whereas the List module adds a layer of abstraction.<br>-&gt; 엘릭서의 원시타입은 구현체이며, 모듈은 원시타입 구현체에 추상레이어를 추가한 것이다.<br>-&gt; 가령 Map은 원시타입이지만, keyword 타입을 통해 딕셔너리 튜플 리스트 형태로 표현할 수 있다. 이 경우, 리스트에서 제공하는 풍부한 모듈을 함께 사용할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;리스트와-재귀&quot;&gt;&lt;a href=&quot;#리스트와-재귀&quot; class=&quot;headerlink&quot; title=&quot;리스트와 재귀&quot;&gt;&lt;/a&gt;리스트와 재귀&lt;/h3&gt;&lt;h4 id=&quot;Heads-and-Tails&quot;&gt;&lt;a href=&quot;#Heads-and-Tails&quot; c
      
    
    </summary>
    
      <category term="Elixir" scheme="https://parkdoyeon.github.io/elixir/"/>
    
    
      <category term="elixir" scheme="https://parkdoyeon.github.io/tags/elixir/"/>
    
      <category term="type" scheme="https://parkdoyeon.github.io/tags/type/"/>
    
      <category term="module" scheme="https://parkdoyeon.github.io/tags/module/"/>
    
  </entry>
  
  <entry>
    <title>Programming Elixir 3 - 함수</title>
    <link href="https://parkdoyeon.github.io/elixir/elixir-2020-01-27-elixir-basic-function/"/>
    <id>https://parkdoyeon.github.io/elixir/elixir-2020-01-27-elixir-basic-function/</id>
    <published>2020-01-27T01:58:08.000Z</published>
    <updated>2020-02-23T01:34:13.471Z</updated>
    
    <content type="html"><![CDATA[<h3 id="엘릭서의-함수"><a href="#엘릭서의-함수" class="headerlink" title="엘릭서의 함수"></a>엘릭서의 함수</h3><p>엘릭서는 같은 이름을 가졌더라도 인자로 받는 파라미터 갯수가 다른 함수를 서로 구분한다. 그러나 코드 작성의 관점에서 혼란을 줄 수 있으므로 이런 상황은 피하는 것이 좋다.</p><h3 id="함수의-매칭"><a href="#함수의-매칭" class="headerlink" title="함수의 매칭"></a>함수의 매칭</h3><p>앨릭서는 같은 이름의 함수를 호출할 때 매칭되는 함수를 ‘순서대로’호출한다. 예컨데 다음과 같이 재귀함수를 구현할 때,</p><pre><code>defmodule Factorial do  def of(0), do: 1  def of(n), do: n*of(n-1)end</code></pre><p>첫번째에 해당하는 케이스가 아니면 두번째 of함수를 호출한다.<br>만약 Factorial내부의 함수가 <code>of(n)</code>이 먼저 등장하는 순서로 구현이 되어있으면, <code>f(0)</code>이 절대 도달불가능하므로 컴파일시 경고를 띄운다.</p><h3 id="When"><a href="#When" class="headerlink" title="When"></a>When</h3><p>함수 인자의 validity를 체크할때 사용. 더 명확하게 표현 가능하다.</p><h3 id="함수의-기본값"><a href="#함수의-기본값" class="headerlink" title="함수의 기본값"></a>함수의 기본값</h3><p><code>\\</code>를 통해 함수인자의 기본 값 부여가 가능하다</p><pre><code>iex&gt; def func(p1 \\ 1) do: IO inspect p1#p1이 없으면 파라미터로 1이 넘어감.</code></pre><p>그러나 같은 이름을 갖는 함수의 경우 혼란을 막기 위해 기본값을 사용하는 함수가 먼저 매칭되지 않도록 하자.</p><h3 id="defp"><a href="#defp" class="headerlink" title="defp"></a>defp</h3><p>모듈 내 프라이빗 함수선언은 <code>defp</code>로 가능하다.<br>그러나 모뉼 내 같은 이름을 가지면서 어떤 함수는 프라이빗하고 어떤 함수는 퍼블릭할 수 없다.</p><h3 id="pipe-operator-gt-을-통한-메소드-체이닝"><a href="#pipe-operator-gt-을-통한-메소드-체이닝" class="headerlink" title="pipe operator |&gt;을 통한 메소드 체이닝"></a>pipe operator |&gt;을 통한 메소드 체이닝</h3><p>DB커넥션 구문같이 호출 결과를 인자로 받을 때 <code>|&gt;</code>를 사용하면 더 깔끔하게 표현가능하다.<br><code>|&gt;</code>구문은 왼쪽의 구문 결과값을 인자로 오른쪽 메소드를 호출한다</p><pre><code>list|&gt; sales_tax(2018)|&gt; prepare_filing#아래와 동일prepare_filing(sales_tax(list, 2018))</code></pre><p>*주의, 파이프 오퍼레이터 사용시 함수의 경우 반드시 괄호를 사용해야한다.<br>파이프 오퍼레이터는 ‘프로그래밍은 데이터를 변환하는 것’이라는 정의에 맞게, 데이터 변환 과정을 명시적으로 표기할 수 있도록 한다.</p><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>엘릭서에서 모듈 내에 내장된 모듈은 환상이다. 모든 모듈은 최상위 레벨에 존재하며, 마침표는 하위 모듈을 불러오지 않고 네임스페이스로만 동작한다. 가령 Mix.Tasks.Doctest와 Mix라는 두 모듈은 서로 어떤 연관성도 갖지 않는다.</p><h3 id="Directive"><a href="#Directive" class="headerlink" title="Directive"></a>Directive</h3><p>import는 불러온 모듈의 이름을 일일히 호명하지 않아도 스코프 안에서 모듈 내 내장된 함수를 사용할 수 있도록 한다.<br><code>alias, defmodule, import, def</code>와 같은 derective구문은 <code>end</code>를 만날때 까지 해당 스코프 내에서 유효하다.<br><code>alias … as</code>를 통해 import하는 모듈의 표현을 단축할 수 있다. <code>as</code>를 생략하면 마지막 네임스페이스만 사용하면 된다.</p><pre><code>defmodule Example do  def compile_and_go(source) do    alias My.Other.Module.Parser, as: Parser    alias My.Other.Module.Runner, as: Runner#혹은 #    alias My.Other.Module.Parser#    alias My.Other.Module.Runner 로도 쓸 수 있다.  endend</code></pre><h3 id="모듈의-이름"><a href="#모듈의-이름" class="headerlink" title="모듈의 이름"></a>모듈의 이름</h3><p>내부적으로 모듈의 이름은 전부 아톰타입이다. 대문자로 시작하는 모든 이름을 지으면 엘릭서는 자동적으로 Elixir라는 접두어를 붙인다. 때문에 모든 함수는 아톰+점(.)+함수명형태의 아톰이다.</p><pre><code>iex&gt; is_atom IOTrueiex&gt; to_string IO“Elixir.IO&quot;iex&gt; :”Elixir.IO” === IOtrueiex&gt; :”Elixir.IO”.puts 123123:ok</code></pre><h3 id="erlang과-elixir"><a href="#erlang과-elixir" class="headerlink" title="erlang과 elixir"></a>erlang과 elixir</h3><p>언랭 컨벤션은 엘릭서와 다르므로, 언랭 함수 호출시에는 언랭 규칙에 따라 호출하면 된다.<br>엘릭서와 달리 언랭은 아톰타입이 소문자로 시작하고 변수가 대문자로 시작한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;엘릭서의-함수&quot;&gt;&lt;a href=&quot;#엘릭서의-함수&quot; class=&quot;headerlink&quot; title=&quot;엘릭서의 함수&quot;&gt;&lt;/a&gt;엘릭서의 함수&lt;/h3&gt;&lt;p&gt;엘릭서는 같은 이름을 가졌더라도 인자로 받는 파라미터 갯수가 다른 함수를 서로 구분한다. 
      
    
    </summary>
    
      <category term="Elixir" scheme="https://parkdoyeon.github.io/elixir/"/>
    
    
      <category term="elixir" scheme="https://parkdoyeon.github.io/tags/elixir/"/>
    
      <category term="function" scheme="https://parkdoyeon.github.io/tags/function/"/>
    
      <category term="functional" scheme="https://parkdoyeon.github.io/tags/functional/"/>
    
  </entry>
  
  <entry>
    <title>Programming Elixir 2 - 자료형과 오퍼레이터</title>
    <link href="https://parkdoyeon.github.io/elixir/elixir-2020-01-24-elixir-basic-types/"/>
    <id>https://parkdoyeon.github.io/elixir/elixir-2020-01-24-elixir-basic-types/</id>
    <published>2020-01-24T01:53:30.000Z</published>
    <updated>2020-02-23T01:34:13.471Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Interger"><a href="#Interger" class="headerlink" title="Interger"></a>Interger</h3><p>언더스코어(_)를 통해 콤마를 대체해서 1000단위를 구분할 수 있다. (편의상 표기할때 사용, 컴파일시 무시됨)</p><pre><code>iex&gt; 123_456_789123456789</code></pre><p>숫자 앞에 0x, 0o, 0b 등을 써서 16진수, 8진수, 2진수 등을 표기할 수 있음</p><pre><code>iex&gt; 0x4165</code></pre><p><code>?c</code> 처럼 쓰면 c의 UTF 문자열 코드포인트를 반환한다</p><pre><code>iex&gt; ?≠ 88008800</code></pre><h3 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h3><p>엘릭서에서 등장하는 값 자료형 중 하나.<br>값이 곧 이름인 자료형으로, 콜론을 앞에 붙여서 표현하거나, 대문자로 시작하는 단어로 표현한다.</p><pre><code>iex&gt; DictionaryDictionaryiex&gt; is_atom(Dictionary)True</code></pre><p>따라서 같은 이름을 갖는 아톰타임은 어떤 프로그램끼리 만나도 동일한 값으로 취급한다. ex) 내장함수에서 사용하는 :ok</p><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>엘릭서에서 nil은 falsy한 값으로 취급한다</p><h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h3><p>보통 2-3개 정도의 작은 데이터들을 다룰때 사용. 플래그 된 값들을 표기할때 많이 쓴다.</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>엘릭서의 list는 중심기능으로서,  array가 아닌 linked list이다.<br>따라서 array와 달리 재귀적으로 사용되며, 암시적으로 전체를 순회하며 사용되는 array와 달리 선언적인 함수형 언어에 더 적합한 자료형이다.<br>데이터 수정시 변형하지 않고 포인터를 활용한다.<br>keyword lists: 튜플형 인자를 사용하여 Key-value페어 형식으로도 표현가능하다. 함수의 인자로 받을때는 브라켓과 리스트 꺽쇄도 제거 하고 표현 할 수 있다.</p><blockquote><p>The chances are very good that your current language has arrays. They’re probably one of your go-to data structures. You like being able to say “go get the nth element.”</p></blockquote><blockquote><p>But arrays are a data structure suited more to imperative programming, because you must explicitly iterate over them, using an external index. And they are prone to off-by-one errors.</p></blockquote><blockquote><p>On the other hand, lists are a recursive data structure, and turn out to be well suited to a functional or declarative style.</p></blockquote><blockquote><p>It’s a change of perspective that can be hard to make. Stick at it, because once you’re comfortable with lists, you won’t want to go back.</p></blockquote><blockquote><p>To show you some of the power of lists, we need to cover just one more language topic: pattern matching. That’s what the next chapter is about</p></blockquote><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>리스트와 달리 중복된 키값을 허용하지 않는 자료형. 따라서 value접근하는 방법이 하나다. 서로 다른 자료형을 가진 key값을 허용한다. 예컨데 key값으로 아톰이나 튜플도 가능.<br>아톰 키값의 경우 map[:key]와 같이 접근하면 키값이 없으면 nil이 반환되지만, dot notation(map.key)의 경우 no matching keys 익셉션이 발생한다.<br>key값을 0부터 순차적으로 커지는 숫자값으로 지정해 array처럼 구현하기도 할 수 있다. 엘릭서에서 pure array가 있다면 그것보다는 못하겠지만, reasonable한 size의 콜렉션이라면 O(1)의 빅오를 가지며 나쁘지 않은 성능을 보인다고한다.</p><h3 id="With"><a href="#With" class="headerlink" title="With"></a>With</h3><p><code>with … do … end</code> 형식으로 사용<br>함수와 같은 구문형식을 갖기 때문에 첫번째 arg는 꼭 <code>with</code>옆에 위치시키거나 괄호로 감싸줘야한다.<br><code>with</code>과 <code>do</code> 구문 사이에 로컬스코프 생성<br>패턴매칭에 실패할때 실패 결과를 다룰 수 있게 해줌<br><code>=</code>대신 <code>&lt;-</code> 사용하므로써 예외 상황 발생시 nil처리<br>do와 같은 라인에 작성하면 end 쓰지 않고 숏컷으로 작성할 수 있다</p><h3 id="amp-Operator"><a href="#amp-Operator" class="headerlink" title="&amp; Operator"></a>&amp; Operator</h3><p>두가지 의미를 갖는다.</p><p>첫째, 함수표현 다음에 나타나는 표현식을 가리키는 숏컷<br>ex) <code>fn p1, p2 -&gt; p1+p2</code>은 <code>&amp;(&amp;1+&amp;2)</code>와 같음</p><p>둘째, 문자식과 함께 사용되는 연산자를 가리킨다</p><pre><code>iex&gt; s = &amp;”bacon and #{&amp;1}”#Function&lt;6.99386804/1 in :erl_eval.expr/5&gt;iex&gt; s.(“custard”)“bacon and custard&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Interger&quot;&gt;&lt;a href=&quot;#Interger&quot; class=&quot;headerlink&quot; title=&quot;Interger&quot;&gt;&lt;/a&gt;Interger&lt;/h3&gt;&lt;p&gt;언더스코어(_)를 통해 콤마를 대체해서 1000단위를 구분할 수 있다. (편의상 표
      
    
    </summary>
    
      <category term="Elixir" scheme="https://parkdoyeon.github.io/elixir/"/>
    
    
      <category term="elixir" scheme="https://parkdoyeon.github.io/tags/elixir/"/>
    
  </entry>
  
  <entry>
    <title>Programming Elixir 1 - 원리</title>
    <link href="https://parkdoyeon.github.io/elixir/elixir-2020-01-23-elixir-basic-principle/"/>
    <id>https://parkdoyeon.github.io/elixir/elixir-2020-01-23-elixir-basic-principle/</id>
    <published>2020-01-23T01:48:16.000Z</published>
    <updated>2020-02-23T01:34:13.470Z</updated>
    
    <content type="html"><![CDATA[<h3 id="확장자-convention"><a href="#확장자-convention" class="headerlink" title="확장자 convention"></a>확장자 convention</h3><p><code>.ex</code></p><ul><li>바이트코드로 컴파일 되고 실행됨</li><li>바이너리 파일로 컴파일 해야할때 사용하는 확장자</li><li>프로그램 어플리케이션으로 사용됨</li></ul><p><code>.exs</code></p><ul><li>컴파일 없이 쓰는 스크립트 프로그램</li><li>소스레벨에서 interpret됨</li><li>보통 테스트 코드에 사용</li></ul><h3 id="Elixir-asserts-variable-not-assigns"><a href="#Elixir-asserts-variable-not-assigns" class="headerlink" title="Elixir asserts variable, not assigns."></a>Elixir asserts variable, not assigns.</h3><p>엘릭서는 변수를 merge 하듯이 사용한다. 하지만 이미 값이 부여된 변수의 경우 그 값을 보관하기때문에(variables bind once per match), 이와 다른 값(value)과 매치하면 매치에러가 발생한다. 다시말해, 엘릭서에서의 ‘=’ 수학에서의 수식과 유사한 의미를 갖는다. 프로그래밍을 하면서 제일 먼저 버리게되는 등호에 대한 직관을 다시 되찾아옴. (하지만 왼쪽 항에서 계산연산을 하지는 않음)</p><pre><code>iex&gt; a = 11ies&gt; 1 = a1Iex&gt; 2 = a** (MatchError) no match of right hand side value: 1</code></pre><p>2와 a는 매치되지 않으므로 매치에러 발생</p><p>엘릭서는 “Fail early”하는 것이 reliable한 코드 작성을 위한 방법이다. 때문에 아래와 같은 패턴이 자주 사용된다.</p><pre><code>{ :ok, file } = File.open(“/etc/passwd”)</code></pre><p>성공하면 file에 객체가 담기겠지만 그렇지 않으면 :error가 리턴되면서 MatchError 익셉션이 발생할 것이다.<br>패턴매칭, 파이프 오퍼레이터를 사용하면 </p><h3 id="variables-bind-once-per-match"><a href="#variables-bind-once-per-match" class="headerlink" title="variables bind once per match"></a>variables bind once per match</h3><pre><code>iex&gt; [a, a] = [1, 1][1, 1]iex&gt; a1iex&gt; [b, b] = [1, 2]** (MatchError) no match of right hand side value: [1, 2]iex&gt; [a, a] = [2, 2]# 새로운 매치이기 때문에 에러발생 안함</code></pre><p>Force existing value<br>기존 값을 고수하고싶다면 캐럿(caret)마크로 표기한다. 기존 값이 아닌 다른 값이 매치되면 Exception이 발생한다.</p><pre><code>Iex&gt; a = 11iex&gt; [^a, 2, 3] = [8, 2, 3]MatchError </code></pre><h3 id="Immutability"><a href="#Immutability" class="headerlink" title="Immutability"></a>Immutability</h3><p>일반 언어는 기존 데이터를 통해 새로운 데이터를 생성할때 기존 데이터가 “변할 수도 있기”때문에 복제본을 생성한다.<br>그러나 엘릭서의 모든 값은 변하지 않는다는 약속이 지켜지므로, 원본 데이터의 단순 참조를 통해 새로운 데이터를 생성할 수도 있다. 무척 효율적.</p><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><p>엘릭서는 여러 프로세스에서 실행되기 때문에 각 프로세스별로 힙이 생성되고, 프로세스가 종료되면 바로 힙을 날리기 때문에 gc가 무척 빠르게 돌아간다. 때문에 기존 언어에서 사용되지 않은 오래된 값이 메모리를 잡고 있는 문제를 해소한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;확장자-convention&quot;&gt;&lt;a href=&quot;#확장자-convention&quot; class=&quot;headerlink&quot; title=&quot;확장자 convention&quot;&gt;&lt;/a&gt;확장자 convention&lt;/h3&gt;&lt;p&gt;&lt;code&gt;.ex&lt;/code&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Elixir" scheme="https://parkdoyeon.github.io/elixir/"/>
    
    
      <category term="elixir" scheme="https://parkdoyeon.github.io/tags/elixir/"/>
    
  </entry>
  
  <entry>
    <title>리눅스 도커 lftp로 파일 배포하기</title>
    <link href="https://parkdoyeon.github.io/dev-env/dev-env-2019-11-21-docker-lftp-ci/"/>
    <id>https://parkdoyeon.github.io/dev-env/dev-env-2019-11-21-docker-lftp-ci/</id>
    <published>2019-11-21T02:58:43.000Z</published>
    <updated>2020-02-23T01:34:13.470Z</updated>
    
    <content type="html"><![CDATA[<p>CI 서버에서 npm 빌드가 완료되면 빌드된 파일을 ftp 통해서 웹서버에 배포하기로했다.<br>CI서버에서 설치하고 쓸 ftp를 찾다가 lftp의 도커 이미지가 있어서 CI 파이프라인에 추가했다.<br>lftp는 리눅스에서 많이 사용하는 ftp 프로그램으로, http를 포함한 다양한 프로토콜을 지원한다. 기본적인 명령어 형식은 아래와 같다.</p><pre><code>lftp ftp://[user_id]:[user_password]@[host]:[port] -e &quot;mirror -R -n -v -p -X *.md -X *.db -X *.yml -X @html/ -X *.git/ $CI_PROJECT_DIR/vue/vue-proj/dist /R2/vue/vue-proj-1125;&quot;</code></pre><p>명령어에 담긴 flag 의미는 아래와 같다</p><ul><li>e: –delete, 동기화 과정중에 없는 파일을 삭제한다</li><li>R: –recursive, 본래 mirror는 [목적지] [로컬] 순서로 디렉토리 표기가 되고 로컬에 목적지에 있는 파일을 다운로드 받는 명령어인데, 반대로 목적지에 파일을 전달하고 싶으면 R 플래그를 넣어줘야 한다.</li><li>n: –only-newer, 새롭게 변경된 파일만 다운로드하기</li><li>v: –verbose, 파일 전송 로그를 표기하기</li><li>p: –no-perms, 작업이 완료되고 리눅스에서 원격에 있는 파일 권한을 변경하려하는데 </li><li>X: –exclude-glob, glob 정규식으로 제외파일을 표기한다. 일반 정규식과 달리 asterisk(*)가 와일드카드 의미를 갖는다.</li></ul><p>자세한 내용 및 더 많은 옵션은 <a href="https://lftp.yar.ru/lftp-man.html" rel="external nofollow noopener noreferrer" target="_blank">lftp 공식 문서</a>를 통해 확인하면 된다.</p><p>해당 stage 스크립트를  <code>gitlab-ci.yml</code>에 작성하니 아래와 같아졌다.</p><pre><code>deploy_prod_vue_event:    image: registry.mycompany.com:5001/mwienk/docker-lftp:latest    stage: deploy    variables:        GIT_STRATEGY: none    script:        - echo &quot;Deploy to alpha server&quot;        - lftp ftp://deploy:$FTP_PASSWORD@172.0.0.1:2100 -e &quot;mirror -R -n -v -p -X *.md -X *.db -X *.yml -X @html/ -X *.git/ $CI_PROJECT_DIR/vue/vue-proj/dist /R2/vue/vue-proj-1125;&quot;    environment:        name: production    tags:        - ci-linux    when: manual    only:    - master</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CI 서버에서 npm 빌드가 완료되면 빌드된 파일을 ftp 통해서 웹서버에 배포하기로했다.&lt;br&gt;CI서버에서 설치하고 쓸 ftp를 찾다가 lftp의 도커 이미지가 있어서 CI 파이프라인에 추가했다.&lt;br&gt;lftp는 리눅스에서 많이 사용하는 ftp
      
    
    </summary>
    
      <category term="Dev-Env" scheme="https://parkdoyeon.github.io/dev-env/"/>
    
    
      <category term="docker" scheme="https://parkdoyeon.github.io/tags/docker/"/>
    
      <category term="ci/cd" scheme="https://parkdoyeon.github.io/tags/ci-cd/"/>
    
      <category term="ftp" scheme="https://parkdoyeon.github.io/tags/ftp/"/>
    
  </entry>
  
  <entry>
    <title>리눅스 계정잠금 해제</title>
    <link href="https://parkdoyeon.github.io/dev-env/dev-env-2019-11-05-linux-password/"/>
    <id>https://parkdoyeon.github.io/dev-env/dev-env-2019-11-05-linux-password/</id>
    <published>2019-11-05T08:41:56.000Z</published>
    <updated>2020-02-23T01:34:13.469Z</updated>
    
    <content type="html"><![CDATA[<p>리눅스 계정 잠금 제어는 보통 pam_tally2로 한다. 접속 시도 횟수가 정책상 설정된 횟수를 초과하면 계정 잠금이 일어나는데 이때 다른 계정으로 접근해서 아래 명령어로 잠금 계정을 해제해줘야 한다.</p><pre><code>pam_tally2 -u [lockeduser] -r</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;리눅스 계정 잠금 제어는 보통 pam_tally2로 한다. 접속 시도 횟수가 정책상 설정된 횟수를 초과하면 계정 잠금이 일어나는데 이때 다른 계정으로 접근해서 아래 명령어로 잠금 계정을 해제해줘야 한다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pam_tall
      
    
    </summary>
    
      <category term="Dev-Env" scheme="https://parkdoyeon.github.io/dev-env/"/>
    
    
      <category term="linux" scheme="https://parkdoyeon.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>npm 빌드위한 docker gitlab CI 세팅 삽질기</title>
    <link href="https://parkdoyeon.github.io/javascript/javascript-2019-10-28-gitlab-ci-docker/"/>
    <id>https://parkdoyeon.github.io/javascript/javascript-2019-10-28-gitlab-ci-docker/</id>
    <published>2019-10-28T06:13:20.000Z</published>
    <updated>2020-02-23T01:34:13.472Z</updated>
    
    <content type="html"><![CDATA[<p>vue.js를 프로덕션에 도입하면서 빌드와 배포를 하는 파이프라인 구축이 필요했다. 젠킨스와 깃랩을 함께 사용할수도 있었겠지만, 기존에 설정되어있는 깃랩 CI를 확장해 도커 깃랩 러너를 통해 npm 빌드를 하는 환경구성을 해보기로 했다.</p><h1 id="How-To"><a href="#How-To" class="headerlink" title="How To"></a>How To</h1><p>gitlab runner docker로 설치하고, 설정파일 생성하기</p><blockquote><p>참고 - <a href="https://docs.gitlab.com/runner/install/" rel="external nofollow noopener noreferrer" target="_blank">깃랩 러너 설치 가이드</a></p></blockquote><pre><code>docker pull gitlab/gitlab-runnerdocker run --rm \-v /gitlab-runner/config:/etc/gitlab-runner/config \-it gitlab/gitlab-runner register</code></pre><p>register 과정에서 깃랩 프로젝트 내에서 생성된 gitlab runner token값과 코디네이션 url을(ex. <a href="https://gilab.mycompany.com/ci" rel="external nofollow noopener noreferrer" target="_blank">https://gilab.mycompany.com/ci</a>) 넣어줘야한다. 그러면 볼륨 매핑한 config 디렉토리에 <code>config.toml</code>파일이 생성된다.</p><p>설정이 완료되고 러너가 돌아가면 깃랩 페이지에서 내가 생성한 러너가 확인 된다. 이 자체로 러너를 돌리기엔 부족할 확률이 높다. 아래와 같이 상황에 맞춰 내가 원하는 설정을 추가적으로 넣어줘야한다.</p><pre><code>concurrent = 1check_interval = 0listen_address = &quot;0.0.0.0:443&quot;[session_server]  listen_address = &quot;0.0.0.0:5092&quot;  session_timeout = 1800[[runners]]  name = &quot;gitlab runner linux&quot;  url = &quot;https://gitlab.mycompany.com/ci&quot;  token = &quot;***************&quot;  executor = &quot;docker&quot;  [runners.custom_build_dir]  [runners.docker]    tls_verify = false    pull_policy = &quot;if-not-present&quot;    privileged = true    disable_entrypoint_overwrite = false    oom_kill_disable = false    disable_cache = false    environment = [ &quot;DOCKER_DRIVER=overlay2&quot; ]    cache_dir = &quot;/data/volume/gitlab-runner/cache&quot;    volumes = [&quot;/var/run/docker.sock:/var/run/docker.sock&quot;, &quot;/data/volume/gitlab-runner/builds:/builds&quot;]    shm_size = 0  [runners.cache]    [runners.cache.s3]    [runners.cache.gcs]</code></pre><h1 id="Trouble-Shooting"><a href="#Trouble-Shooting" class="headerlink" title="Trouble Shooting"></a>Trouble Shooting</h1><p>하지만 이 설정파일을 만들기까지 매우 많은 삽질이 있었다.</p><h4 id="도커-통신이-정상적으로-안되는-경우"><a href="#도커-통신이-정상적으로-안되는-경우" class="headerlink" title="도커 통신이 정상적으로 안되는 경우"></a>도커 통신이 정상적으로 안되는 경우</h4><p> 나는 docker로 깃랩러너를 돌린 다음에 깃랩 러너 컨테이너와 같은 층위에 다른 도커 이미지(node나 python 이미지와 같은)를 사용해서 빌드를 하고싶었다. 이 때 이미지를 불러와야하는데 계속 볼륨으로 바인딩한 도커 서비스간에 통신이 안돼서 build failure가 발생했다.</p><blockquote><p>빌드 로그</p></blockquote><pre><code class="bash">Skipping Git submodules setup$ docker infoClient:Debug Mode: falseServer:errors pretty printing infoERROR: error during connect: Get http://docker:2375/v1.40/info: dial tcp: lookup docker on 10.101.200.3:53: server misbehavingERROR: Job failed: exit code 1</code></pre><p>혹시 볼륨 바인딩에 문제가 있는건 아닐까? 싶어서 찾아봤더니 깃랩 러너가 돌아가고있는 드라이버를 따로 표기를 해줘야한다는 글이 있어서, 환경변수로 overlay2를 넣어줬더니 정상빌드 됐다. 여기서 볼륨설정을 모든 컨테이너에 적용하고싶다면 위와같이 runner.docker에 환경변수로 넣어주면된다. 프로젝트별로 바인딩 하고싶다면 variable값으로 <code>.gitlab-ci</code> 파일에 설정해주면 된다.</p><pre><code>variables:    DOCKER_DRIVER: overlay2</code></pre><h4 id="npm-프록시-세팅하기"><a href="#npm-프록시-세팅하기" class="headerlink" title="npm 프록시 세팅하기"></a>npm 프록시 세팅하기</h4><p>폐쇄된 네트워크이기 때문에 npm 패키지를 설치할때 proxy설정을 해줘야했다. 처음에 도커 이미지에 프록시 세팅을 하려했다. 러너를 통해 생성되는 도커이미지에 프록시를 세팅하려면 아래와 같이 <code>.gitlab-ci.yml</code>파일을 수정하면 된다.</p><blockquote><p>참고 <a href="https://docs.docker.com/network/proxy/" rel="external nofollow noopener noreferrer" target="_blank">도커 프록시 설정</a></p></blockquote><pre><code class="yaml">#.gitlab-ci.ymlimage: node:13variables:    HTTPS_PROXY: &quot;https://registry.mycompany.com/repository/npm-group/&quot;    HTTP_PROXY: &quot;http://registry.mycompany.com/repository/npm-group&quot;</code></pre><p>하지만 이렇게 하면 gitlab 코드를 받아올때도 프록시 설정이 적용되어 문제가 된다. no proxy옵션을 지정해주면 되지만, 앞으로 빌드하면서 어떤 url을 호출할지 알 수 없기 때문에 npm만 지정된 프록시로 우회하도록 설정하는게 깔끔하다. npm 자체적인 설정을 통해 가능하므로, ci 파일에 npm 프록시를 설정하는 스크립트를 넣어준다.</p><pre><code class="yml">before_script:    - npm config set registry http://packages.webzen.com/repository/npm-group/</code></pre><p>사실 이 부분도 삽질을 조금 했다. npm config에 https_proxy라는 값을 세팅해줄 수 있는데, 여기에 세팅되는 프록시 주소는 registry 프록시가 아니라 패키지가 다운로드하는 url들의 프록시를 의미한다. <a href="https://docs.npmjs.com/misc/config" rel="external nofollow noopener noreferrer" target="_blank">공식문서</a>에 나와있는 설명은 이렇다.</p><blockquote><p>https-proxy§<br>Default: null<br>Type: url<br>A proxy to use for outgoing https requests. If the HTTPS_PROXY or https_proxy or HTTP_PROXY or http_proxy environment variables are set, proxy settings will be honored by the underlying request library.</p></blockquote><p>완성된 .gitlab-ci.yml파일은 이렇다.</p><pre><code class="yml">image: node:13variables:    CHROMEDRIVER_FILEPATH: &quot;/builds/chromedriver/chromedriver_linux64.zip&quot;before_script:    - npm config set registry http://registry.mycompany.com/repository/npm-group/stages:    - buildtest_build:    stage: build    script:        - echo &quot;build vue js&quot;        - cd $CI_PROJECT_DIR/vue/somepage        - npm i        - npm run build    environment:        name: test    tags:        - linux-runner    only:    - vue-branch</code></pre><blockquote><p>공식문서/참고자료<br><a href="https://docs.gitlab.com/runner/executors/docker.html" rel="external nofollow noopener noreferrer" target="_blank">도커 executor 가이드</a><br><a href="https://docs.gitlab.com/ee/ci/docker/using_docker_images.html" rel="external nofollow noopener noreferrer" target="_blank">도커 이미지와 함께 빌드하기</a><br><a href="https://docs.gitlab.com/ee/ci/docker/using_docker_build.html" rel="external nofollow noopener noreferrer" target="_blank">도커 빌드하기</a><br><a href="https://docs.gitlab.com/runner/configuration/proxy.html" rel="external nofollow noopener noreferrer" target="_blank">깃랩 러너 프록시 가이드</a><br><a href="https://gitlab.com/gitlab-org/gitlab-ci-runner/issues/10" rel="external nofollow noopener noreferrer" target="_blank">coordinator url이란?</a><br><a href="https://gitlab.com/johandurancerdas/gitlab-cicd-tutorial" rel="external nofollow noopener noreferrer" target="_blank">참고 프로젝트</a><br><a href="https://www.youtube.com/watch?v=8h6IK9VkCQQ" rel="external nofollow noopener noreferrer" target="_blank">참고 강의</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;vue.js를 프로덕션에 도입하면서 빌드와 배포를 하는 파이프라인 구축이 필요했다. 젠킨스와 깃랩을 함께 사용할수도 있었겠지만, 기존에 설정되어있는 깃랩 CI를 확장해 도커 깃랩 러너를 통해 npm 빌드를 하는 환경구성을 해보기로 했다.&lt;/p&gt;

      
    
    </summary>
    
      <category term="JavaScript" scheme="https://parkdoyeon.github.io/javascript/"/>
    
    
      <category term="docker" scheme="https://parkdoyeon.github.io/tags/docker/"/>
    
      <category term="javascript" scheme="https://parkdoyeon.github.io/tags/javascript/"/>
    
      <category term="node" scheme="https://parkdoyeon.github.io/tags/node/"/>
    
      <category term="npm" scheme="https://parkdoyeon.github.io/tags/npm/"/>
    
      <category term="gitlab" scheme="https://parkdoyeon.github.io/tags/gitlab/"/>
    
      <category term="ci" scheme="https://parkdoyeon.github.io/tags/ci/"/>
    
      <category term="container" scheme="https://parkdoyeon.github.io/tags/container/"/>
    
  </entry>
  
  <entry>
    <title>window에서 python 버전 구분해서 실행하기</title>
    <link href="https://parkdoyeon.github.io/python/python-2019-10-18-window-python2/"/>
    <id>https://parkdoyeon.github.io/python/python-2019-10-18-window-python2/</id>
    <published>2019-10-18T09:16:19.000Z</published>
    <updated>2019-10-28T16:08:17.108Z</updated>
    
    <content type="html"><![CDATA[<p>node-sass을 폐쇄된 윈도우 ci에서 빌드하기위해 어쩔수없이 python 2.x버전을 설치했는데, 에러가 발생했다. node-sass를 빌드하는 node-gyp이 파이썬을 실행할 때 커맨드라인에서 <code>python2</code>를 사용하는데, unix기반 os에서는 파이썬 버전에 따라 python2, python3와 같은 변수가 실행명령어로 바인딩이 되지만 윈도우는 그렇지 않기 때문이다(깃헙에 윈도우 환경을 고려해달라는 이슈가 올라와있다). 할수없이 커맨드 라인에서 <code>python2</code> 명령어를 인식할 수 있도록 환경변수를 세팅했다.</p><h1 id="윈도우와-python-환경변수-세팅"><a href="#윈도우와-python-환경변수-세팅" class="headerlink" title="윈도우와 python 환경변수 세팅"></a>윈도우와 python 환경변수 세팅</h1><p>파이썬은 설치시 환경변수 세팅 옵션을 체크하면 자동으로 변수를 세팅한다. 윈도우 <code>제어판 &gt; 시스템 &gt; 고급시스템설정 &gt; 환경변수</code>에 들어가면 사용자 변수 혹은 시스템 변수에 Path 라는 변수명을 갖고있는 값이 있다. 파이썬 환경변수 세팅이 됐다면 여기에 기존 파이썬 경로들이 나오는데, path의 입력 순서에 따라 첫번째로 작성된 파이썬 경로가 디폴트로 호출된다. 가령 아래와같이 입력이 되어있다면,</p><pre><code>C:\Users\doyeon\AppData\Local\Programs\Python\Python38-32\Scripts\C:\Users\doyeon\AppData\Local\Programs\Python\Python38-32\C:\Users\doyeon\AppData\Local\Programs\Python\Python37-32\Scripts\C:\Users\doyeon\AppData\Local\Programs\Python\Python37-32\</code></pre><p>Python38-32가 상위에 입력이 되어있으므로 커맨드라인에서 <code>python</code>을 호출할 때 python 3.8이 실행된다. </p><h1 id="py-3-8로-버전-구분해서-실행하기"><a href="#py-3-8로-버전-구분해서-실행하기" class="headerlink" title="py -3.8로 버전 구분해서 실행하기"></a>py -3.8로 버전 구분해서 실행하기</h1><p>unix 체제와 다를뿐이지 윈도우에서도 버전을 구분해서 실행할 수 있는 기본 명령어가 있다.<code>py -3.7</code> 혹은 <code>py -3.8</code>와 같은 형태로 입력하면된다.</p><pre><code>C:\Users\doyeon&gt;py -3.7Python 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 21:26:53) [MSC v.1916 32 bit (Intel)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt;</code></pre><h1 id="python-3-x를-메인으로-쓰면서-파이썬-2-7-세팅하기"><a href="#python-3-x를-메인으로-쓰면서-파이썬-2-7-세팅하기" class="headerlink" title="python 3.x를 메인으로 쓰면서 파이썬 2.7 세팅하기"></a>python 3.x를 메인으로 쓰면서 파이썬 2.7 세팅하기</h1><p>하지만 나처럼 python을 3.x버전대로 쓰면서 unix os처럼 python2를 호출하고싶다면, 우선 파이썬2를 설치하고 해당 경로를 환경변수로 추가해야한다. 가령 파이썬이 <code>c:\Python27</code>에 설치가 되었다면 해당 경로를 38버전 뒤에 추가해준다.</p><pre><code>C:\Users\doyeon\AppData\Local\Programs\Python\Python38-32\Scripts\C:\Users\doyeon\AppData\Local\Programs\Python\Python38-32\c:\Python27\Scriptsc:\Python27\</code></pre><p>그리고 python2를 사용하기 위해서 <code>c:\Python27\</code>경로에 있는 <code>python.exe</code>파일의 이름을 <code>python2.exe</code>로 바꿔준다.</p><pre><code>C:\Users\doyeon&gt;python2Python 2.7.16 (v2.7.16:ef4ec6ed12, Mar 25 2019, 21:26:53) [MSC v.1916 32 bit (Intel)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;node-sass을 폐쇄된 윈도우 ci에서 빌드하기위해 어쩔수없이 python 2.x버전을 설치했는데, 에러가 발생했다. node-sass를 빌드하는 node-gyp이 파이썬을 실행할 때 커맨드라인에서 &lt;code&gt;python2&lt;/code&gt;를 사용
      
    
    </summary>
    
      <category term="Python" scheme="https://parkdoyeon.github.io/python/"/>
    
    
      <category term="python" scheme="https://parkdoyeon.github.io/tags/python/"/>
    
      <category term="python2" scheme="https://parkdoyeon.github.io/tags/python2/"/>
    
      <category term="python3" scheme="https://parkdoyeon.github.io/tags/python3/"/>
    
      <category term="path" scheme="https://parkdoyeon.github.io/tags/path/"/>
    
  </entry>
  
  <entry>
    <title>vue cli 3.X 버전에 typscript, webpack 세팅하기</title>
    <link href="https://parkdoyeon.github.io/javascript/javascript-2019-10-16-vue-cli-typescript/"/>
    <id>https://parkdoyeon.github.io/javascript/javascript-2019-10-16-vue-cli-typescript/</id>
    <published>2019-10-16T07:37:08.000Z</published>
    <updated>2019-10-16T14:43:27.904Z</updated>
    
    <content type="html"><![CDATA[<p>처음에 엄청나게 삽질을 하게되는데 하고나면 또 별거아닌… 것중 하나가 웹팩세팅 아닌가 싶다. 이번에 SPA도입하면서 본격적으로 vue 빌드환경을 세팅해보게 되었는데, vue.js도 그렇지만 프론트엔드 개발환경구성 관련 기술들을 처음 접해봐서 그런지 많이 헤맸다. 해보고나니 헤맨만큼 더 잘 알것같은 느낌이 들어 좋은 경험이었다.</p><h1 id="vue-cli-설치하기"><a href="#vue-cli-설치하기" class="headerlink" title="vue cli 설치하기"></a>vue cli 설치하기</h1><p>vue cli는 2.X대랑 3.X대가 변화가 큰 편이다. 혹시 구버전이 있으면 프로젝트 생성 명령어부터 다르니 반드시 두 버전을 확인하고 개발해야한다.</p><pre><code class="bash">npm i -g @vue/cli</code></pre><h1 id="vue-cli-프로젝트-생성하기"><a href="#vue-cli-프로젝트-생성하기" class="headerlink" title="vue cli 프로젝트 생성하기"></a>vue cli 프로젝트 생성하기</h1><pre><code class="bash">vue create [project-name]</code></pre><p>타입스크립트를 추가하고싶으면 프로젝트 생성시 설정단계를 통해 타입스크립트를 추가해도 되고, 생성된 프로젝트에 명령어로 typescript를 추가해도 된다.</p><h1 id="생성된-vue-프로젝트에-typescript-추가하는-법"><a href="#생성된-vue-프로젝트에-typescript-추가하는-법" class="headerlink" title="생성된 vue 프로젝트에 typescript 추가하는 법"></a>생성된 vue 프로젝트에 typescript 추가하는 법</h1><pre><code class="bash">vue add typescript</code></pre><p>타입스크립트 추가를 하면 <code>main.js</code>가 <code>main.ts</code>로 변경되고, 내가 설정한 옵션에 따라 이 경로에 <code>shims-tsx.d.ts</code>와 <code>shims-vue.d.ts</code>파일이 생성된다.</p><h1 id="webpack-연동하기"><a href="#webpack-연동하기" class="headerlink" title="webpack 연동하기"></a>webpack 연동하기</h1><p>vue cli는 웹팩 위에서 빌드되는 프로젝트이므로 기본 설정만으로도 당장 테스트하기에 충분하지만 그래도 webpack에서 사용하던 설정들을 몇가지 붙여야하면 <code>vue.config.js</code>를 통해 세팅하면 된다. 최초에 기본 생성되는 파일이 아니므로 직접 만들어야한다.</p><p>기본적으로 지원되는 옵션은 <a href="https://cli.vuejs.org/config/#global-cli-config" rel="external nofollow noopener noreferrer" target="_blank">공식문서</a>를 참조해서 작성하고, 나머지는 <code>configureWebpack</code>을 통해 설정한다. 해당 키값으로 설정된 옵션들은 <code>webpack</code>옵션에 <code>merge</code>되면서 빌드된다.</p><pre><code class="javascript">const path          = require(&#39;path&#39;),    UglifyJsPlugin  = require(&#39;uglifyjs-webpack-plugin&#39;);    rootconfig      = require(&#39;./root.config&#39;)();module.exports = {    publicPath: &#39;/&#39;,    outputDir: path.resolve(__dirname, &#39;./dist/&#39;+ rootconfig.buildpath),    configureWebpack: {        entry: {            app : &#39;./src/&#39; + rootconfig.buildpath + &#39;main.ts&#39;,        },        output: {            filename: &#39;bundle.js&#39;        },        resolve: {            alias: {                &#39;@&#39;: path.resolve(__dirname, &#39;src/&#39; + rootconfig.buildpath)            }        },        optimization: {            minimize: true,            minimizer: [                new UglifyJsPlugin({                    uglifyOptions:                    {                        sourceMap: true,                        warnings: false,                        compress: {                            unused: true                        },                        mangle: false,                        beautify: true,                        output: {                            comments: false                        }                    }                })            ]        }    }};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;처음에 엄청나게 삽질을 하게되는데 하고나면 또 별거아닌… 것중 하나가 웹팩세팅 아닌가 싶다. 이번에 SPA도입하면서 본격적으로 vue 빌드환경을 세팅해보게 되었는데, vue.js도 그렇지만 프론트엔드 개발환경구성 관련 기술들을 처음 접해봐서 그런
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://parkdoyeon.github.io/javascript/"/>
    
    
      <category term="javascript" scheme="https://parkdoyeon.github.io/tags/javascript/"/>
    
      <category term="node" scheme="https://parkdoyeon.github.io/tags/node/"/>
    
      <category term="typescript" scheme="https://parkdoyeon.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Visual Studio Code 유용한/기본적인 세팅들</title>
    <link href="https://parkdoyeon.github.io/dev-env/dev-env-2019-10-08-vs-code-window/"/>
    <id>https://parkdoyeon.github.io/dev-env/dev-env-2019-10-08-vs-code-window/</id>
    <published>2019-10-08T07:26:55.000Z</published>
    <updated>2020-02-23T01:34:13.469Z</updated>
    
    <content type="html"><![CDATA[<p><em>2019년 10월 8일부터 작성 시작, 꾸준히 업데이트할 예정이다.</em></p><h1 id="IDE-디자인"><a href="#IDE-디자인" class="headerlink" title="IDE 디자인"></a>IDE 디자인</h1><ul><li><p>unique window colors<br>새로운 윈도우 띄울때마다 컬러가 바뀐다. 여러창 띄워놓고 작업할 때 유용하다.<br><a href="https://marketplace.visualstudio.com/items?itemName=stuart.unique-window-colors" rel="external nofollow noopener noreferrer" target="_blank">https://marketplace.visualstudio.com/items?itemName=stuart.unique-window-colors</a></p></li><li><p>rainbow brakets<br>괄호를 여닫을 때 다양한 색상으로 표기. Elasticsearch 쿼리 만들때 유용하게 썼다.<br><a href="https://marketplace.visualstudio.com/items?itemName=2gua.rainbow-brackets" rel="external nofollow noopener noreferrer" target="_blank">https://marketplace.visualstudio.com/items?itemName=2gua.rainbow-brackets</a></p></li><li><p>indent rainbow<br>코드 내 들여쓰기 정도를 컬러를 입혀서 구분한다. 색상도 vscode의 톤앤 매너에 맞는 은은한 컬러라 보기 좋다. dot으로 구분하는 라이브러리도 많은데 개인적으로는 색상 표현이 더 직관적인 것 같다.<br><a href="https://marketplace.visualstudio.com/items?itemName=oderwat.indent-rainbow" rel="external nofollow noopener noreferrer" target="_blank">https://marketplace.visualstudio.com/items?itemName=oderwat.indent-rainbow</a></p></li></ul><h1 id="마크다운"><a href="#마크다운" class="headerlink" title="마크다운"></a>마크다운</h1><ul><li>markdown all in one<br>마크다운 작성할때 단축키를 써서 작업할 수 있다<br><a href="https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one" rel="external nofollow noopener noreferrer" target="_blank">https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;2019년 10월 8일부터 작성 시작, 꾸준히 업데이트할 예정이다.&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;IDE-디자인&quot;&gt;&lt;a href=&quot;#IDE-디자인&quot; class=&quot;headerlink&quot; title=&quot;IDE 디자인&quot;&gt;&lt;/a&gt;IDE 디자인&lt;/h1
      
    
    </summary>
    
      <category term="Dev-Env" scheme="https://parkdoyeon.github.io/dev-env/"/>
    
    
      <category term="vscode" scheme="https://parkdoyeon.github.io/tags/vscode/"/>
    
      <category term="ide" scheme="https://parkdoyeon.github.io/tags/ide/"/>
    
  </entry>
  
  <entry>
    <title>yarn 설치하고 다른 경로에 있는 node_modules 참조하기</title>
    <link href="https://parkdoyeon.github.io/javascript/javascript-2019-10-08-yarn-node/"/>
    <id>https://parkdoyeon.github.io/javascript/javascript-2019-10-08-yarn-node/</id>
    <published>2019-10-08T07:25:28.000Z</published>
    <updated>2019-10-08T09:47:57.660Z</updated>
    
    <content type="html"><![CDATA[<p>vue.js 개발환경을 구축하면서 노드파일을 관리해야하는 이슈가 생겼다. 배포시 디렉토리 구조가 아래와 같은데</p><pre><code class="powershell"> MYDIR/   projects/     project_a        /package.json        /node_modules     project_b        /package.json        /node_modules     project_c        /package.json        /node_modules</code></pre><p>  이 상태에서 신규 디렉토리 배포가 나가면 <code>npm i</code>명령 마다 이미 빌드서버에 설치한 패키지가 중복되는 것은 물론, <code>node_modules</code> 디렉토리가 하드디스크를 가득 차지하는 문제가 발생한다. </p><p>  그래서 아래와 같이 각 프로젝트가 하나의 노드 모듈을 바라보도록 수정하기로 했다.</p><pre><code class="powershell"> MYDIR/   projects/     node_modules/     project_a        /package.json     project_b        /package.json     project_c        /package.json</code></pre><h1 id="방법"><a href="#방법" class="headerlink" title="방법"></a>방법</h1><p><a href="https://stackoverflow.com/questions/26293049/specify-path-to-node-modules-in-package-json" rel="external nofollow noopener noreferrer" target="_blank">스택오버플로우</a>에서 찾은 환경변수 변경하는 방법은 윈도우 환경에서는 잘 동작하지 않았다. yarn을 사용하는 방법이 있길래, 이참에 한번 설치해보았다.</p><h1 id="yarn이란"><a href="#yarn이란" class="headerlink" title="yarn이란?"></a>yarn이란?</h1><p>node 모듈관리를 조금 더 체계적으로 하기 위한 패키지 관리 툴이다. 별도의 용도를 목적으로 하지만 기본적으로 기존에 세팅된 npm프로젝트와 함께 사용해도 된다는 점이 좋다. 나는 단순히 노드 모듈 참조를 조금더 간단한 설정으로 세팅하고싶어 설치했지만, <a href="https://academy.realm.io/kr/posts/mobilization-konstantin-raev-taming-node-modules-at-facebook/" rel="external nofollow noopener noreferrer" target="_blank">이 포스트(Facebook은 Node_Modules를 어떻게 관리할까요?)</a>를 참조하길 권한다. 2017년에 작성된 오래된 글이지만 yarn의 개념과 도입의도를 파악할 수 있는 좋은 글이다.</p><h1 id="yarn-설치와-사용법"><a href="#yarn-설치와-사용법" class="headerlink" title="yarn 설치와 사용법"></a>yarn 설치와 사용법</h1><p>간단하다. npm을 통해 설치하고 npm대신 yarn을 사용하면 된다.</p><pre><code>npm i -g yarn# vue.js 시작인 경우npm run devyarn run dev</code></pre><h1 id="다른-경로의-노드-모듈-참조하기"><a href="#다른-경로의-노드-모듈-참조하기" class="headerlink" title="다른 경로의 노드 모듈 참조하기"></a>다른 경로의 노드 모듈 참조하기</h1><p>아래와같이 서로 다른 package.json설정을 갖는 프로젝트가 있을때, yarn을 통해 프로젝트 디렉토리마다 node_modules를 생성하지 않고 상위에 있는 node_modules를 참조할 수 있다.</p><p>방법 1. 실행 명령어를 통해 설정하기</p><pre><code class="powershell">yarn run dev --modules-folder ../node_modules</code></pre><p>방법 2. 설정파일 만들기<br>package.json이 있는 root 경로에 .yarnrc파일을 생성하고 아래 내용을 입력한다</p><pre><code class="powershell">--modules-folder ../node_modules</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;vue.js 개발환경을 구축하면서 노드파일을 관리해야하는 이슈가 생겼다. 배포시 디렉토리 구조가 아래와 같은데&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;powershell&quot;&gt; MYDIR/
   projects/
     project_a
     
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://parkdoyeon.github.io/javascript/"/>
    
    
      <category term="javascript" scheme="https://parkdoyeon.github.io/tags/javascript/"/>
    
      <category term="node" scheme="https://parkdoyeon.github.io/tags/node/"/>
    
      <category term="yarn" scheme="https://parkdoyeon.github.io/tags/yarn/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript - 정규식으로 문자열 replace하기</title>
    <link href="https://parkdoyeon.github.io/javascript/javascript-2019-09-17-js-replace-regex/"/>
    <id>https://parkdoyeon.github.io/javascript/javascript-2019-09-17-js-replace-regex/</id>
    <published>2019-09-17T12:44:23.000Z</published>
    <updated>2019-09-17T16:07:37.754Z</updated>
    
    <content type="html"><![CDATA[<p><code>&#39;2019-09-17&#39;</code>을 <code>&#39;2019/09/17&#39;</code>으로 바꾸려면 replace()를 사용해야 될 것같지만, replace()는 <strong>가장 먼저 등장하는 문자열만</strong> 교체한다. 때문에 전체 문자열에서 변경사항을 적용하려면 다음과 같이 정규식을 사용해야한다.</p><pre><code class="javascript">var item = &#39;2019-09-17&#39;item.replace(/-/g, &#39;/&#39;)</code></pre><p>정규식 끝에 있는 소문자는 ‘전체탐색’을 의미한다. i와 함께 많이 사용되는데, 정리하면 아래와 같다.</p><ul><li>i: ignore case, 대문자/소문자 구분하지 않음</li><li>g: global, 전체 탐색</li></ul><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/replace" rel="external nofollow noopener noreferrer" target="_blank">MDN 문서</a>에 좋은 예시들이 많이 나오는데, 아래와 같은 사용도 가능하다.</p><pre><code class="javascript">var re = /(\w+)\s(\w+)/;var str = &#39;John Smith&#39;;var newstr = str.replace(re, &#39;$2, $1&#39;);console.log(newstr);  // Smith, John</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;&amp;#39;2019-09-17&amp;#39;&lt;/code&gt;을 &lt;code&gt;&amp;#39;2019/09/17&amp;#39;&lt;/code&gt;으로 바꾸려면 replace()를 사용해야 될 것같지만, replace()는 &lt;strong&gt;가장 먼저 등장하는 문자열만&lt;/s
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://parkdoyeon.github.io/javascript/"/>
    
    
      <category term="regex" scheme="https://parkdoyeon.github.io/tags/regex/"/>
    
      <category term="javascript" scheme="https://parkdoyeon.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>파이썬 heapq로 리스트 빠르게 정렬하기</title>
    <link href="https://parkdoyeon.github.io/python/python-2019-07-31-python-heapq/"/>
    <id>https://parkdoyeon.github.io/python/python-2019-07-31-python-heapq/</id>
    <published>2019-07-31T12:45:45.000Z</published>
    <updated>2019-07-31T15:42:53.408Z</updated>
    
    <content type="html"><![CDATA[<h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><ol><li>어떤 리스트(somearr)에서 가장 작은 원소 두개를 꺼내서</li><li>연산(원소1+원소2*2)한 다음</li><li>연산결과를 리스트(somearr)에 다시 넣는다. </li><li>리스트의 모든 원소가 일정 기준(point) 이상이 될 때 까지 이 동작을 반복한다.</li></ol><pre><code class="python">somearr = [1, 2, 3, 9, 10, 12]point = 7</code></pre><h3 id="list-sort"><a href="#list-sort" class="headerlink" title="list.sort()"></a>list.sort()</h3><p>이 동작을 일반 리스트를 통해 구현하면 어떨까? 코드자체는 단순하다. 그러나 가장 작은 원소를 찾기위해 정렬을 해야하며, 모든 원소를 확인하며 정렬하는 sort()로는 리스트가 길어질수록 여기에 비례한만큼 긴 시간이 소요된다.</p><pre><code class="python">somearr.sort()while somearr[0] &lt; point:    if len(sorsomearr) &lt; 3: return -1    sorsomearr.append(sorsomearr.pop(0)+(sorsomearr.pop(0)*2))    somearr.sort()</code></pre><h3 id="deque-popleft-deque-appendleft"><a href="#deque-popleft-deque-appendleft" class="headerlink" title="deque.popleft(), deque.appendleft()"></a>deque.popleft(), deque.appendleft()</h3><p>그렇다면 pop과 append연산을 deque모듈을 임포트해서 구현하는 것은 어떨까? </p><pre><code class="python">from collections import dequedeque_arr = deque(sorted(somearr))while deque_arr[0] &lt; point:    if len(deque_arr) &lt; 3: return -1    deque_arr.appendleft(deque_arr.popleft()+(deque_arr.popleft()*2))    sorted(deque_arr)</code></pre><p>왼쪽에 연산 결과를 추가한다고해서 더 빠르게 정렬이 일어난다는 보장도 없거니와, 연산 결과값으로 추가되는 왼쪽 원소가 반드시 최소가 된다는 보장은 없으므로, 결국엔 리스트 정렬을 해야한다. 특별히 효과를 보지 못한다.</p><h3 id="heapq-heappop-heapq-heappush"><a href="#heapq-heappop-heapq-heappush" class="headerlink" title="heapq.heappop(), heapq.heappush()"></a>heapq.heappop(), heapq.heappush()</h3><p>이 때 활용하면 좋은 모듈이 heapq다. heapq는 이진트리의 자료구조를 구현해낸 모듈로, 일반 리스트 데이터를 파라미터로 받아 이진트리 알고리즘으로 정렬한 다음 원소를 꺼내거나 삭제한다. </p><pre><code class="python">import heapqheapq.heapify(somearr) # 리스트 오브젝트를 정렬한다answer = 0while somearr[0] &lt; K:    if len(somearr) &lt; 2: return -1    heapq.heappush(somearr, heapq.heappop(somearr)+heapq.heappop(somearr)*2)</code></pre><p>heappush, heappop 모두 자료 삭제/추가와 동시에 정렬이 이어나는 자료구조로, 별도의 sort가 필요없다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;어떤 리스트(somearr)에서 가장 작은 원소 두개를 꺼내서&lt;/li&gt;
&lt;li&gt;연산(원소1+원소2*2)한 다음&lt;/l
      
    
    </summary>
    
      <category term="Python" scheme="https://parkdoyeon.github.io/python/"/>
    
    
      <category term="python" scheme="https://parkdoyeon.github.io/tags/python/"/>
    
      <category term="sort" scheme="https://parkdoyeon.github.io/tags/sort/"/>
    
      <category term="heapq" scheme="https://parkdoyeon.github.io/tags/heapq/"/>
    
  </entry>
  
  <entry>
    <title>파이썬 sort()함수 key 파라미터 제대로 사용하기</title>
    <link href="https://parkdoyeon.github.io/python/python-2019-07-28-python-sort-key/"/>
    <id>https://parkdoyeon.github.io/python/python-2019-07-28-python-sort-key/</id>
    <published>2019-07-28T07:36:48.000Z</published>
    <updated>2019-07-31T15:29:54.630Z</updated>
    
    <content type="html"><![CDATA[<p>지난번에 작성한 <a href="./2019-07-21-python-sort">big sort에 대한 글</a>에서 casting을 통한 정렬을 위해 sort함수의 key파라미터에 대해 설명했는데 최근에 문제를 풀다가 몇가지 사용방법을 더 알게되었다. key 파라미터는 정렬의 기준이 되는 값을 제공하는 내장함수이다. 2차원 리스트를 정렬할때 sort함수는 기본으로 첫번째 인자를 기준으로 정렬한다.</p><pre><code class="python">student_point = [(400, 6), (200, 1), (300, 3), (210, 2), (400, 7)]</code></pre><h3 id="key-itemgetter-사용하기"><a href="#key-itemgetter-사용하기" class="headerlink" title="key=itemgetter 사용하기"></a>key=itemgetter 사용하기</h3><p>그렇다면 인자마다 또 다른 iterable object를 갖는 2차원 오브젝트에 접근하여 정렬하려면 어떻게 해야할까? 첫번째 방법은 itemgetter를 사용하는 것이다. itemgetter를 사용하기 위해서는 기본제공 모듈인 operator의 import가 필요하다. itemgetter에 파라미터로 오브젝트의 몇번째 인자를 기준으로 정렬할지 사용할 수 있다. sort함수에 역순옵션을 주면 해당인자를 기준으로 역순으로 정렬해준다.</p><pre><code class="python">from operator import itemgetterstudent_point.sort(key=itemgetter(1), reverse=True)print(student_point)</code></pre><h3 id="key-lambda-사용하기"><a href="#key-lambda-사용하기" class="headerlink" title="key=lambda 사용하기"></a>key=lambda 사용하기</h3><p>두번째 방법은 람다함수를 사용하는 것이다. 람다를 사용하면 operator를 import하지 않고 정렬할 수 있다. 역순으로 정렬하고싶으면 마이너스를 기호를 붙여주면 된다.</p><pre><code class="python">student_point.sort(key=lambda x: -x[1])</code></pre><p>출력 결과</p><pre><code class="bash">[(400, 7), (400, 6), (300, 3), (210, 2), (200, 1)]</code></pre><h3 id="lambda를-사용해-여러기준으로-정렬하기"><a href="#lambda를-사용해-여러기준으로-정렬하기" class="headerlink" title="lambda를 사용해 여러기준으로 정렬하기"></a>lambda를 사용해 여러기준으로 정렬하기</h3><p>lambda는 훨씬 자유도가 높은데, 아래와 같이 여러개의 인자를 리턴하면 앞에있는 인자를 기준으로 하고, 그 다음에는 두번째 인자를 기준으로 정렬한다. 여기서는 마이너스를 붙여줬으므로 앞의 인자 기준으로 정렬하되, 앞의 인자가 동일한 값을 갖게되면 두번째 인자를 기준으로 역순으로 정렬한다. 쉽게 말하면, 리턴된 인자가 정렬의 대상이 되는 인자인 것처럼 오브젝트를 다룬다!</p><pre><code class="python">student_point.sort(key=lambda x: (x[0], -x[1]))</code></pre><p>출력 결과</p><pre><code class="bash">[(200, 1), (210, 2), (300, 3), (400, 7), (400, 6)]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;지난번에 작성한 &lt;a href=&quot;./2019-07-21-python-sort&quot;&gt;big sort에 대한 글&lt;/a&gt;에서 casting을 통한 정렬을 위해 sort함수의 key파라미터에 대해 설명했는데 최근에 문제를 풀다가 몇가지 사용방법을 더 알게되
      
    
    </summary>
    
      <category term="Python" scheme="https://parkdoyeon.github.io/python/"/>
    
    
      <category term="python" scheme="https://parkdoyeon.github.io/tags/python/"/>
    
      <category term="sort" scheme="https://parkdoyeon.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>파이썬 dictionary활용을 위한 빌트인 함수들</title>
    <link href="https://parkdoyeon.github.io/python/python-2019-07-24-python-dict/"/>
    <id>https://parkdoyeon.github.io/python/python-2019-07-24-python-dict/</id>
    <published>2019-07-23T16:03:58.000Z</published>
    <updated>2019-07-31T15:29:54.629Z</updated>
    
    <content type="html"><![CDATA[<p>DB를 잘 쓰려면 쿼리를 알아야 하듯이, 알고리즘 문제를 풀다보면 정확한 자료형을 구현하기위해선 빌트인 함수를 잘 써야한다. 가령 아래 배열에서 같은 인덱스 값을 갖는 값들이 어떤 곡의 장르와 플레이 횟수라고 했을때, 장르별 플레이 횟수 합산을 하고, 횟수 단위로 순위를 매기려면 어떻게 해야할까?</p><pre><code class="python">genres = [&quot;classic&quot;, &quot;pop&quot;, &quot;classic&quot;, &quot;classic&quot;, &quot;pop&quot;]plays = [500, 600, 150, 500, 2500]</code></pre><p>코드적으로 의미를 해석하면, 장르별 데이터라면 2개의 값이 서로 key-value관계를 가지며, 특정 장르별로 합산이 되어야한다는 것은 중복되지 않는 key값 단위로 합산이 이루어진다는 것을 의미한다. 이것을 순서로 정리하면</p><ol><li>해당 key값을 갖는 딕셔너리를 생성한 다음에</li><li>연산을 위해 0을 value로 할당하고 </li><li>순회하면서 더하고</li><li>순위를 매긴다.<br>단순해보이지만 여기까지도 다양한 선택지가 존재한다. 여기 동일한 로직을 적용했지만 코드가 다른 두개의 방법이 있다. <h3 id="방법-1-fromkeys로-딕셔너리-생성후-index를-직접-순회하며-더하기"><a href="#방법-1-fromkeys로-딕셔너리-생성후-index를-직접-순회하며-더하기" class="headerlink" title="방법 1: fromkeys로 딕셔너리 생성후 index를 직접 순회하며 더하기"></a>방법 1: fromkeys로 딕셔너리 생성후 index를 직접 순회하며 더하기</h3>fromkeys는 순회가능한 리스트를 key값으로 생성한 딕셔너리를 만든다. 주의할점은 두번째 파라미터값으로 초기값을 받는데, 여기에 list()를 할당하면 <strong>같은 주소값을 갖는다.</strong> 즉, 해당 value값의 변형이 일어나면 <strong><em>모든 key에 대응하는 list값이 영향을 받는다.</em></strong> 때문에 list할당시에는 comprehension이나 아래에 defaultdict()함수를 사용해야한다. fromkeys르 딕셔너리 생성후, genres와 plays는 서로 같은 인덱스에 대응하하므로 직접 인덱스 값을 순회하며 플레이 횟수를 더해준다. 합산된 딕셔너리는 다시 순서값이 있는 데이터형인 tuple자료형으로 변환된 다음, sort()로 정렬된다. 2차원 이상의 자료형은 제일 앞의 인자를 기준으로 sort된다.<pre><code class="python">genre_rank_dict = dict.fromkeys(genres, 0) # 딕셔너리 생성for i in range(len(plays)): genre_rank_dict[genres[i]] += plays[i]</code></pre></li></ol><p>genre_rank = [(albumrank[g], g) for g in albumrank.keys()]<br>genre_rank.sort(reverse=True)</p><pre><code>### 방법 2: defaultdict으로 생성하고 zip으로 순회하기두번째 바법은 defaultdict으로 빈 딕셔너리를 생성하는데, 람다함수로 초기값을 지정할 수 있다. 초기값을 지정해놓으면 함수연산이 바로 가능하다는 장점이 있다. 딕셔너리 생성 후에는 tuple자료형으로 장르와 재생횟수를 묶어서 dictionary에 넣어준다. zip은 iterable 오브젝트이기 때문에, 위의 방식과 성능적으로 전혀 차이가 없지만 더 명확하고 깔끔한 코드를 작성할 수 있는 장점이 있다. dict자료형이 완성되면 아래도 마찬가지로 items()함수를 호출해 tuple형으로 바꿔주는데, 컴프리헨션을 통해 플레이 휫수 기준으로 정렬된 tuple 리스트에서 장르만 순서대로 빼놓은 리스트를 새로 생성한다.``` pythongenre_rank_dict = defaultdict(lambda: 0) # 딕셔너리 생성for genre, play in zip(genres, plays):    genre_rank_dict[genre] += playgenre_rank = [genre for genre, play in sorted(genre_play_dict.items(), key=itemgetter(1), reverse=True)]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;DB를 잘 쓰려면 쿼리를 알아야 하듯이, 알고리즘 문제를 풀다보면 정확한 자료형을 구현하기위해선 빌트인 함수를 잘 써야한다. 가령 아래 배열에서 같은 인덱스 값을 갖는 값들이 어떤 곡의 장르와 플레이 횟수라고 했을때, 장르별 플레이 횟수 합산을 
      
    
    </summary>
    
      <category term="Python" scheme="https://parkdoyeon.github.io/python/"/>
    
    
      <category term="dictionary" scheme="https://parkdoyeon.github.io/tags/dictionary/"/>
    
      <category term="python" scheme="https://parkdoyeon.github.io/tags/python/"/>
    
      <category term="algorithm" scheme="https://parkdoyeon.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>ASP.NET Core nuget package 배포하기</title>
    <link href="https://parkdoyeon.github.io/csharp/csharp-2019-07-23-nuget/"/>
    <id>https://parkdoyeon.github.io/csharp/csharp-2019-07-23-nuget/</id>
    <published>2019-07-23T06:08:12.000Z</published>
    <updated>2019-07-23T15:43:30.450Z</updated>
    
    <content type="html"><![CDATA[<p>사실 누겟패키지 생성방법은 <a href="https://docs.microsoft.com/ko-kr/nuget/quickstart/create-and-publish-a-package-using-the-dotnet-cli" rel="external nofollow noopener noreferrer" target="_blank">공식문서</a>에 아주 잘 정리되어있다. 이 글은 공식문서를 내 언어로 한번 더 정리하고, 내부 패키지 서버에 배포하는 과정과 거기서 발생한 트러블 슈팅과정을 덧붙이는 것을 목적으로 한다. 닷넷 코어로 빌드한 누겟 패키지를 배포하고 또 닷넷 코어 프로젝트에 적용하면서 기록용으로 글을 작성하게 됐는데, 이전에 일반 닷넷 프레임워크 누겟 패키지 빌드/배포와 크게 달라진 점은 없는 것 같다.</p><p>패키지의 빌드방식은 크게 세가지라고 할 수 있다.</p><h1 id="방법-1-빌드-옵션을-통한-패키지-파일-자동생성"><a href="#방법-1-빌드-옵션을-통한-패키지-파일-자동생성" class="headerlink" title="방법 1. 빌드 옵션을 통한 패키지 파일 자동생성"></a>방법 1. 빌드 옵션을 통한 패키지 파일 자동생성</h1><p>csproj에 아래의 설정값을 추가해주고 빌드하면 bin디렉토리 내 빌드 버전 폴더에 .nupkg파일이 생성된다.</p><pre><code class="xml">  &lt;PropertyGroup Condition=&quot;&#39;$(Configuration)|$(Platform)&#39;==&#39;Debug|AnyCPU&#39;&quot;&gt;    &lt;PackageId&gt;something.for.core&lt;/PackageId&gt;    &lt;Version&gt;1.0.0&lt;/Version&gt;    &lt;Authors&gt;someauthor&lt;/Authors&gt;    &lt;Company&gt;somecompany&lt;/Company&gt;    &lt;GeneratePackageOnBuild&gt;true&lt;/GeneratePackageOnBuild&gt;  &lt;/PropertyGroup&gt;</code></pre><h1 id="방법-2-명령어로-생성하기"><a href="#방법-2-명령어로-생성하기" class="headerlink" title="방법 2. 명령어로 생성하기"></a>방법 2. 명령어로 생성하기</h1><p>빌드 설정에 누겟패키지 설정을 추가하는 것이 귀찮다면(혹은 property값을 굳이 남기고 싶지 않다면) 커맨드라인 명령어로 생성할수도 있다.</p><pre><code class="powershell">dotnet pack -c release</code></pre><h1 id="방법-3-nuget-package-explorer에서-생성하기"><a href="#방법-3-nuget-package-explorer에서-생성하기" class="headerlink" title="방법 3. nuget package explorer에서 생성하기"></a>방법 3. nuget package explorer에서 생성하기</h1><p>GUI를 통해 패키지를 생성할 수 있다. 윈도우 마켓에서 nuget package explorer를 설치해서 빌드하면 된다. 처음에 쓰면 혼란스러운 구석은 있어도 사용 자체는 어렵지 않아서 설명은 생략한다. 빌드 파일의 디렉토리 구성이나 버전별 관리까지 이래저래 손이 가는 부분이 있어서 특별한 경우가 아니면 사용하지 않는 것이 좋은 것 같다.</p><h1 id="배포하기-cmd를-사용한-배포"><a href="#배포하기-cmd를-사용한-배포" class="headerlink" title="배포하기 - cmd를 사용한 배포"></a>배포하기 - cmd를 사용한 배포</h1><p>배포도 마찬가지로 위의 방법 세가지를 다 쓸 수 있다.누겟 익스플로러에서 해도되고, cmd에서 해도 된다. cmd는 아래와 같이 작성하면 된다. </p><pre><code class="powershell">dotnet nuget push something.for.core.nupkg -k somecompany -s https://api.nuget.org/v3/index.json</code></pre><p><code>-k</code>는 키값을 넣는 파라미터인데, 내부서버에 배포하는 경우 키값을 임의로(아무거나) 작성해도 되지만, 누겟서버에 배포하는 경우 발급받은 키값을 입력해야한다.  내 경우 사내에서 사용하는 sonatype nexus package서버에 배포를 해야야 하므로 키값을 임의로 지정했다. 배포 url은 다운로드용으로 연결할때는 <code>https://package.mycompany.com/repository/nuget-group/</code> 주소로 했는데, 배포시에는 <code>https://package.mycompany.com/repository/nuget-hosted/</code>주소로 배포해야 했다. 이 점을 몰라서 조금 헤맸다.</p><h1 id="배포하기-누겟-익스플로러를-사용한-배포"><a href="#배포하기-누겟-익스플로러를-사용한-배포" class="headerlink" title="배포하기 - 누겟 익스플로러를 사용한 배포"></a>배포하기 - 누겟 익스플로러를 사용한 배포</h1><p>누겟 익스플로러에서 배포하는 경우 생성된 로컬 누겟패키지를 익스플로러에서 연 다음 <code>File &gt; Publish</code>를 누르면 아래와같은 팝업이 나온다. 주소와 키값을 넣고 배포 버튼을 누르면 된다.<br><img src="/image/csharp/2019-07-23-nuget-1.png" alt="nuget"><br> 주소입력창 하단에 <code>api/v2/package</code>경로를 배포경로에 더할것인지 체크하는 체크박스가 있는데 하지 않아도 된다.</p><h1 id="FYI-Trouble-Shooting"><a href="#FYI-Trouble-Shooting" class="headerlink" title="FYI - Trouble Shooting"></a>FYI - Trouble Shooting</h1><p>누겟 패키지를 게시하고 프로젝트에서 정상적으로 설치까지 했지만, cs 파일에서 패키지 호출시 네임스페이스를 인식 못하는 문제가 있었다. 이때 패키지 버전을 올려서 게시한 다음 패키지 업데이트를 하니 문제가 해결됐다. 또 그 이후에 다른 누겟 프로젝트를 최초로 빌드해 올렸을때는 정상적으로 레퍼런스 참조가 됐다. 해결법은 찾았지만 재현이 안된다. 대체 무엇이 문제였던 것일까.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;사실 누겟패키지 생성방법은 &lt;a href=&quot;https://docs.microsoft.com/ko-kr/nuget/quickstart/create-and-publish-a-package-using-the-dotnet-cli&quot; rel=&quot;externa
      
    
    </summary>
    
      <category term="C#" scheme="https://parkdoyeon.github.io/csharp/"/>
    
    
      <category term="csharp" scheme="https://parkdoyeon.github.io/tags/csharp/"/>
    
      <category term="dotnetcore" scheme="https://parkdoyeon.github.io/tags/dotnetcore/"/>
    
      <category term="nuget" scheme="https://parkdoyeon.github.io/tags/nuget/"/>
    
  </entry>
  
</feed>
