<!DOCTYPE html>
<html lang>
  <head><meta name="generator" content="Hexo 3.8.0">
    
<!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta name="google-site-verification" content="ZPpg1XKRwaiB4lPx6SawBAA96ROVlVBmZ8s6pigFEVc">



<meta name="naver-site-verification" content="a31e494cb7e78d5a64696ea234dc6c9006b251ff">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">


<meta property="og:type" content="website">
<meta property="og:url" content="https://parkdoyeon.github.io/elk/elk-2019-05-31-es-shards/">


  <meta property="og:title" content="ElasticSearch - unassigned shard 문제 해결 (1) shard가 너무 많을 때">




  <meta name="description" content="ElasticSearch - unassigned shard 문제 해결 (1) shard가 너무 많을 때">
  <meta property="og:description" content="ElasticSearch - unassigned shard 문제 해결 (1) shard가 너무 많을 때">





  <meta name="keywords" content="elasticsearch,shards,template,">





  <link rel="alternate" href="/atom.xml" title="Park Doyeon">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=">



<link rel="canonical" href="https://parkdoyeon.github.io/elk/elk-2019-05-31-es-shards/">


<meta name="description" content="문제상황ELK 스택을 개발하면서 운영 경험이 전무했던 나는 점진적으로 인덱스를 추가하고, 서비스에 지장이 있는 시점부터 확장을 할 계획이었다. 그리고 과거에 잠시 ES용으로 사용했던 서버 2대로 노드를 운영했다. 서버의 스펙은 아래와 같았다.  RAM: 16G CPU: 8 DISK: /DATA 300G, /ROOT 100G  그런데 어느순간부터 서비스 추가">
<meta name="keywords" content="elasticsearch,shards,template">
<meta property="og:type" content="article">
<meta property="og:title" content="ElasticSearch - unassigned shard 문제 해결 (1) shard가 너무 많을 때">
<meta property="og:url" content="https://parkdoyeon.github.io/elk/elk-2019-05-31-es-shards/index.html">
<meta property="og:site_name" content="Park Doyeon">
<meta property="og:description" content="문제상황ELK 스택을 개발하면서 운영 경험이 전무했던 나는 점진적으로 인덱스를 추가하고, 서비스에 지장이 있는 시점부터 확장을 할 계획이었다. 그리고 과거에 잠시 ES용으로 사용했던 서버 2대로 노드를 운영했다. 서버의 스펙은 아래와 같았다.  RAM: 16G CPU: 8 DISK: /DATA 300G, /ROOT 100G  그런데 어느순간부터 서비스 추가">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-06-27T15:33:15.453Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ElasticSearch - unassigned shard 문제 해결 (1) shard가 너무 많을 때">
<meta name="twitter:description" content="문제상황ELK 스택을 개발하면서 운영 경험이 전무했던 나는 점진적으로 인덱스를 추가하고, 서비스에 지장이 있는 시점부터 확장을 할 계획이었다. 그리고 과거에 잠시 ES용으로 사용했던 서버 2대로 노드를 운영했다. 서버의 스펙은 아래와 같았다.  RAM: 16G CPU: 8 DISK: /DATA 300G, /ROOT 100G  그런데 어느순간부터 서비스 추가">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=">
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-141653278-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-141653278-1');
  </script>





  


    <title> ElasticSearch - unassigned shard 문제 해결 (1) shard가 너무 많을 때 - Park Doyeon </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  </head>

  <body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">Park Doyeon</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>
      </header>

      <div id="post-categories"><ul class="category-list">

    <li>
    
        <a href="/dev-env">Dev-Env</a>
    
    </li>

    <li>
    
        <a href="/csharp">C#</a>
    
    </li>

    <li>
    
        <a href="/docker">Docker</a>
    
    </li>

    <li>
    
        <a href="/elk" class="on">ELK</a>
    
    </li>

    <li>
    
        <a href="/ml">ML</a>
    
    </li>

    <li>
    
        <a href="/python">Python</a>
    
    </li>

    <li>
    
        <a href="/sql">SQL</a>
    
    </li>

    <li>
    
        <a href="/web">Web</a>
    
    </li>

</ul>

      </div>

      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          ElasticSearch - unassigned shard 문제 해결 (1) shard가 너무 많을 때
        
      </h1>

      <time class="post-time">
          May 31 2019
      </time>
    </header>



    
            <div class="post-content">
            <h3 id="문제상황"><a href="#문제상황" class="headerlink" title="문제상황"></a>문제상황</h3><p>ELK 스택을 개발하면서 운영 경험이 전무했던 나는 점진적으로 인덱스를 추가하고, 서비스에 지장이 있는 시점부터 확장을 할 계획이었다. 그리고 과거에 잠시 ES용으로 사용했던 서버 2대로 노드를 운영했다. 서버의 스펙은 아래와 같았다.</p>
<ul>
<li>RAM: <code>16G</code></li>
<li>CPU: <code>8</code></li>
<li>DISK: <code>/DATA 300G, /ROOT 100G</code></li>
</ul>
<p>그런데 어느순간부터 서비스 추가할때마다 ES가 죽거나, 안정적인 상태로 돌아오기까지 너무 오랜 시간(약 4시간 정도)이 소요됐다. </p>
<p>RAM이 문제였을까, CPU가 문제였을까(RAM이 <a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/hardware.html" rel="external nofollow noopener noreferrer" target="_blank">이상적인 권장 사양</a>이 아님은 확실했다). 표면적인 징후는 bulk insert 큐가 가득 차는 문제이지만, 이는 시간이 지나거나 초기에 insert하는 데이터를 조절하면 해소가 되는 문제였다. 진짜 문제는 shard 할당에 있었다. </p>
<h3 id="너무-많은-샤드"><a href="#너무-많은-샤드" class="headerlink" title="너무 많은 샤드?"></a>너무 많은 샤드?</h3><p>우선 ES에 찍힌 로그를 봤다. 샤드가 너무 많다는 메세지가 있었다.</p>
<pre><code>#! Deprecation: In a future major version, this request will fail because this action would add [9xx] total shards,
but this cluster currently has [8xxx]/[2000] maximum shards open.
Before upgrading, reduce the number of shards in your cluster or adjust the cluster setting [cluster.max_shards_per_node].</code></pre><p> ES는 워낙 버전 업이 잦은데다 위의 메세지는 deprecation 경고였기 때문에, 가볍게 여겼다. 하지만 아래의 또 다른 에러 메세지를 보고 shard 문제임을 알 수 있었다. 샤드의 할당과 라우팅이 잘 이뤄지지 않는다는 내용이다.</p>
<pre><code>[kr-service-2019.05.25], type [index_stats], id [AV9RswFhsIL8o1ZCN3Mi],
message [UnavailableShardsException[[kr-service-2019.05.25][0] Primary shard is not active or isn&#39;t assigned to a known node. Timeout: [1m], request: org.elasticsearch.action.bulk.BulkShardRequest@4f100b34]]]</code></pre><p>ES 노드 1개의 최대 샤드의 갯수 기본 설정은 2000개이다. 노드당 샤드를 늘려주면 문제가 해결될까 해서 샤드갯수를 5000까지 늘렸다.</p>
<pre><code>PUT /_cluster/settings
{
    &quot;persistent&quot; : {
        &quot;cluster.max_shards_per_nodes&quot; : 5000
    }
}</code></pre><p>메세지는 사라졌지만, unassigned 문제가 해소되진 않았고, ES에 할당된 메모리는 줄어들 생각을 하지 않고 80%이상으로 치고 올라왔다. 부랴부랴 ES 공식사이트에 있는 shard 관리에 대한 <a href="https://www.elastic.co/kr/blog/how-many-shards-should-i-have-in-my-elasticsearch-cluster" rel="external nofollow noopener noreferrer" target="_blank">문서</a>를 읽었다. 매우 중요한 팁들이 있었는대 아래와 같은 내용이었다.</p>
<blockquote>
<p>TIP: 작은 샤드는 작은 세그먼트를 만들며 부하를 증가시킵니다. 평균 샤드 크기를 최소한 수 GB와 수십 GB 사이를 유지하세요. 시간 기반 데이터를 사용한 과거 사례를 보면, 20GB ~ 40GB 정도의 사이즈가 적당합니다.<br><br><br>TIP: 각 샤드의 부하는 세그먼트 개수와 크기에 따라 결정됩니다. forcemerge 기능을 사용하여 작은 세그먼트를 큰 세그먼트로 병합시키세요. 이 작업은 이상적으로 인덱스에 더 이상 데이터가 입력되지 않을 때 실행되어야 합니다. 그리고 무척 부하가 큰 작업이니 피크 시간을 피하여 수행해야 하는 것을 명심하세요.<br><br><br>TIP: 하나의 노드에 저장할 수 있는 샤드의 개수는 가용한 힙의 크기와 비례하지만, Elasticsearch에서 그 크기를 제한하고 있지는 않습니다. 경험상 하나의 노드에 설정한 힙 1GB 당 20개 정도가 적당합니다. 따라서 30GB 힙을 가진 노드는 최대 600개 정도의 샤드를 가지는 것이 가능하지만, 이 보다는 적게 유지하는 것이 더 좋습니다. 일반적으로 이러한 구성은 클러스터를 건강하게 유지하는데 도움이 됩니다</p>
</blockquote>
<p>요약하면 샤드의 갯수와 힙의 크기는 비례하는데, 나는 힙과 사용하는 데이터 크기(한 인덱스당 1~2G정도 사용)에 비해 지나치게 많은 샤드 할당을 하고있었다. 애초에 왜 이런 문제가 생겼는가 보니, Logstash에서 인덱스 생성시 샤드갯수가 5개로 생성되고 있었다. 기본 설정으로. (맙소사)</p>
<h3 id="샤드-줄이기"><a href="#샤드-줄이기" class="headerlink" title="샤드 줄이기"></a>샤드 줄이기</h3><p>우선 생성된 샤드를 일괄로 삭제할수는 없으니, 신규 생성하는 인덱스부터 설정을 바꿔주기로 했다. 방법은 꽤 간단하다. _template 요청으로 인덱스 생성시 샤드 설정을 지정하면 된다.</p>
<pre><code class="curl">GET _template/kr_shards_control
{
  &quot;index_patterns&quot;: &quot;kr-*&quot;,
  &quot;settings&quot;: {
    &quot;number_of_shards&quot;:   2
  }
}</code></pre>
<p>추가적으로 문제가 있던 시점에 추가했던 인덱스를 전부 삭제하고, 필요가 없는 오래된 인덱스도 일부 삭제했다. 그리고 데이터를 다시 받아 샤드 2개짜리로 생성했다. 30분 정도 지나니 메모리 수치도 점차 가라앉고, CPU도 안정되는 것을 확인할 수 있었다. 그리고 퇴근을 했다. 하지만 <a href="/elk/elk-2019-06-18-es-version">다른 문제</a>가 있었는데…</p>

            </div>
          

    
      <footer class="post-footer">
        <div class="post-tags">
          
            <a href="/tags/elasticsearch/">elasticsearch</a>
          
            <a href="/tags/shards/">shards</a>
          
            <a href="/tags/template/">template</a>
          
        </div>

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/ml/ml-2019-06-02-deep2/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Deep Learning From Scratch - 2. 신경망 학습</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/docker/docker-2019-05-30-docker-install/">
        <span class="next-text nav-default">도커/도커 컴포즈 설치하고 서비스 시작하기</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
    <!--<div style="text-align:center;">
        <button class="btn" id="load-disqus" onclick="disqus.load();">load Disqus review</button>
    </div>-->
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
    2019
    <span class="footer-author">Park Doyeon.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> and <a class="theme-link" href="https://github.com/parkdoyeon">Me</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    

<script type="text/javascript">
  var disqus_shortname = 'parkdoyeon';
  var disqus_identifier = 'elk/elk-2019-05-31-es-shards/';
  var disqus_url = 'https://parkdoyeon.github.io/elk/elk-2019-05-31-es-shards/index.html';

  
  var disqus_config = function () {
      this.page.url = disqus_url;
      this.page.identifier = disqus_identifier;
  };
  
  (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
  
  
  // var disqus = {
  //   load : function disqus(){
  //       if(typeof DISQUS !== 'object') {
  //         (function () {
  //         var s = document.createElement('script'); s.async = true;
  //         s.type = 'text/javascript';
  //         s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  //         (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
  //         }());
  //         $('#load-disqus').remove(); ///Delete Button
  //       }
  //   }
  // }

</script>


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script src="/js/src/theme.js?v="></script>
<script src="/js/src/bootstrap.js?v="></script>


    <script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<script src="/js/src/highlight.pack.js?v="></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.7.0/highlightjs-line-numbers.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
  document.querySelectorAll('figure.highlight').forEach((block) => {
    hljs.highlightBlock(block);
  });
});
hljs.initHighlightingOnLoad();
hljs.initLineNumbersOnLoad();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  </body>
</html>
