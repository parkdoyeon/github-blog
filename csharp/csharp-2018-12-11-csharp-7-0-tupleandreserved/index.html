<!DOCTYPE html>
<html lang>
  <head><meta name="generator" content="Hexo 3.8.0">
    
<!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta name="google-site-verification" content="ZPpg1XKRwaiB4lPx6SawBAA96ROVlVBmZ8s6pigFEVc">



<meta name="naver-site-verification" content="a31e494cb7e78d5a64696ea234dc6c9006b251ff">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">


<meta property="og:type" content="website">
<meta property="og:url" content="https://parkdoyeon.github.io/csharp/csharp-2018-12-11-csharp-7-0-tupleandreserved/">


  <meta property="og:title" content="c# 기본서 - c# 7.0: 예약어와 ValueTask/ValueTuple">




  <meta name="description" content="c# 기본서 - c# 7.0: 예약어와 ValueTask/ValueTuple">
  <meta property="og:description" content="c# 기본서 - c# 7.0: 예약어와 ValueTask/ValueTuple">





  <meta name="keywords" content="c#,ref,out,lambda,when,is,c#7.0,tuple,ValueTask,switch/case,">





  <link rel="alternate" href="/atom.xml" title="Park Doyeon">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=">



<link rel="canonical" href="https://parkdoyeon.github.io/csharp/csharp-2018-12-11-csharp-7-0-tupleandreserved/">


<meta name="description" content="7.0 주요변화 c# 7.0출시시 닷넷 버전은 4.6.2였다, 현재 7.0에 대응되는 프레임워크는 4.7이다. ValueTuple 타입이 추가되었다. 그러나 4.6.2 닷넷 프레임워크에는 없으므로 nuget패키지를 통해 System.ValueTuple을 직접 설치해야한다   System.Threading.Tasks.ValueTask가 추가되었는데, 마찬가지">
<meta name="keywords" content="c#,ref,out,lambda,when,is,c#7.0,tuple,ValueTask,switch&#x2F;case">
<meta property="og:type" content="article">
<meta property="og:title" content="c# 기본서 - c# 7.0: 예약어와 ValueTask&#x2F;ValueTuple">
<meta property="og:url" content="https://parkdoyeon.github.io/csharp/csharp-2018-12-11-csharp-7-0-tupleandreserved/index.html">
<meta property="og:site_name" content="Park Doyeon">
<meta property="og:description" content="7.0 주요변화 c# 7.0출시시 닷넷 버전은 4.6.2였다, 현재 7.0에 대응되는 프레임워크는 4.7이다. ValueTuple 타입이 추가되었다. 그러나 4.6.2 닷넷 프레임워크에는 없으므로 nuget패키지를 통해 System.ValueTuple을 직접 설치해야한다   System.Threading.Tasks.ValueTask가 추가되었는데, 마찬가지">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-06-08T02:58:52.613Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="c# 기본서 - c# 7.0: 예약어와 ValueTask&#x2F;ValueTuple">
<meta name="twitter:description" content="7.0 주요변화 c# 7.0출시시 닷넷 버전은 4.6.2였다, 현재 7.0에 대응되는 프레임워크는 4.7이다. ValueTuple 타입이 추가되었다. 그러나 4.6.2 닷넷 프레임워크에는 없으므로 nuget패키지를 통해 System.ValueTuple을 직접 설치해야한다   System.Threading.Tasks.ValueTask가 추가되었는데, 마찬가지">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=">
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-141653278-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-141653278-1');
  </script>





  


    <title> c# 기본서 - c# 7.0: 예약어와 ValueTask/ValueTuple - Park Doyeon </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  </head>

  <body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">Park Doyeon</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>
      </header>

      <div id="post-categories"><ul class="category-list">

    <li>
    
        <a href="/docker">Docker</a>
    
    </li>

    <li>
    
        <a href="/csharp" class="on">C#</a>
    
    </li>

    <li>
    
        <a href="/dev-env">Dev-Env</a>
    
    </li>

    <li>
    
        <a href="/ml">ML</a>
    
    </li>

    <li>
    
        <a href="/python">Python</a>
    
    </li>

    <li>
    
        <a href="/sql">SQL</a>
    
    </li>

    <li>
    
        <a href="/elk">ELK</a>
    
    </li>

    <li>
    
        <a href="/web">Web</a>
    
    </li>

</ul>

      </div>

      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          c# 기본서 - c# 7.0: 예약어와 ValueTask/ValueTuple
        
      </h1>

      <time class="post-time">
          Dec 7 2018
      </time>
    </header>



    
            <div class="post-content">
            <h3 id="7-0-주요변화"><a href="#7-0-주요변화" class="headerlink" title="7.0 주요변화"></a>7.0 주요변화</h3><ul>
<li>c# 7.0출시시 닷넷 버전은 4.6.2였다, 현재 7.0에 대응되는 프레임워크는 4.7이다.</li>
<li><code>ValueTuple</code> 타입이 추가되었다.<ul>
<li>그러나 4.6.2 닷넷 프레임워크에는 없으므로 nuget패키지를 통해 <code>System.ValueTuple</code>을 직접 설치해야한다</li>
</ul>
</li>
<li><code>System.Threading.Tasks.ValueTask</code>가 추가되었는데, 마찬가지로 지원하지 않으므로 <code>System.Threading.Tasks.Extensions.dll</code>을 참조추가해야한다.</li>
</ul>
<h3 id="out-매개변수-쉽게-사용하기"><a href="#out-매개변수-쉽게-사용하기" class="headerlink" title="out 매개변수 쉽게 사용하기"></a>out 매개변수 쉽게 사용하기</h3><ul>
<li>기본에는 out매개변수 사용을 위해서는 따로 선언을 해줬어야했지만, 이제는 타입을 함께 입력해주면 선언이 필요없다.<pre><code class="c#">  int.TryParse(&quot;5&quot;, out int result);
  int.TryParse(&quot;6&quot;, out int result); //컴파일시 6.0코드로 변환 하기때문에 같은 변수명으로 입력하면 컴파일 에러발생!</code></pre>
</li>
</ul>
<h3 id="반환값-로컬변수에-ref-사용"><a href="#반환값-로컬변수에-ref-사용" class="headerlink" title="반환값/로컬변수에 ref 사용"></a>반환값/로컬변수에 ref 사용</h3><ul>
<li>메서드를 통해 배열의 특정 요소만 반환하는 등의 사용이 가능하다</li>
<li>가독성 문제가 있지만 메서드의 값 설정과 할당이 동시에 가능해진다.<pre><code class="c#">  class MyMetrix
  {
      int[,] _matrix = new int[100, 100]
      public ref int Put(int c, int r)
      {
          return ref _matrix[c, r];
      }
  }
  {
      MyMetrix m = new MyMetrix();
      int result = Matrix.Put(1, 1) = 1;
      Console.WriteLine(result) //1
  }</code></pre>
</li>
<li>주의할 점은 메서드 내부에서 선언한 지역변수와 같은 경우 실행 후 호출측으로 넘어갈 때 스택이 해제되어 return ref으로 반환된 인스턴스가 남아있을거라는 보장이 없다.</li>
<li>또한, ref 예약어를 지정한 지역변수는 다시 다른 변수를 가리키도록 변경할 수 없다.</li>
</ul>
<h3 id="ValueTuple-도입-이유-dynamic-System-Tuple의-한계"><a href="#ValueTuple-도입-이유-dynamic-System-Tuple의-한계" class="headerlink" title="ValueTuple 도입 이유: dynamic, System.Tuple의 한계"></a>ValueTuple 도입 이유: dynamic, System.Tuple의 한계</h3><ul>
<li>튜플은 기본적으로 여러개의 요소를 반환해야하지만 일일히 클래스를 만들기가 번거로울 때 사용된다.<ul>
<li>물론 아래와같이 c# 3.0의 익명 타입과 4.0의  dynamic 예약어를 이용할수도 있지만, 런타임시 리스크가 있다.<pre><code class="c#">{
    dynamic result = ParseInteger(&quot;20&quot;); //dynamic
    Console.WriteLine(result.Parsed);
    Console.WriteLine(result.Number);
    //정적 형식검사가 안돼 나중이 필드 이름이 바뀌어도 컴파일시 문제를 알아낼 수 없는 문제가 있다.
}
dynamic ParseInteger(string text)
{
    int number = 0;
    try
    {
        number = Int32.Parse(text);
        return new { Number = number, Parsed = true }; //익명 타입
    }
    catch
    {
        return new { Number = number, Parsed = false };
    }
}</code></pre>
</li>
</ul>
</li>
<li>System.Tuple을 이용해 문제를 해결할수도 있지만<ul>
<li>변수 이름이 무조건 Item1, 2.. 와같이 정해지며</li>
<li>파이썬과같은 언어랑 비교했을 때 상대적으로 복잡하다.<pre><code class="c#">{
    Tuple&lt;bool, int&gt; result = pg.ParseInteger(&quot;40&quot;);
}
Tuple&lt;bool, int&gt; ParseInteger(string text)
{
    int number = 0;
    bool result = false;
    try
    {
        number = Int32.Parse(text);
        result = true
    }
    catch { }
    return Tuple.create(result, number);
}</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="ValueTuple의-도입"><a href="#ValueTuple의-도입" class="headerlink" title="ValueTuple의 도입"></a>ValueTuple의 도입</h3><ol>
<li>Return 타입에 직접 이름을 지정하거나, 호출하는 측에서 강제로 이름을 지정할수도 있다.</li>
<li>item1, item2 .. 과같은 방식의 호출도 가능하다.</li>
<li>out 매개변수 처리에서 지원했던 생략기호도 반환값 분해 구문에 사용할 수 있다.</li>
</ol>
<ul>
<li><p>모든 튜플은 제너릭 타입으로 변경해서 처리한다</p>
<ul>
<li>닷넷 4에서 제공하는 System.Tuple은 class 타입으로 정의된 반면</li>
<li>4.7의 ValueTuple은 struct로 정의되어있다는 차이가 있다.</li>
</ul>
</li>
<li><p>Deconstruct라는 특별한 이름을 지정한 메서드를 정의해서 out 파라미터를 받아 직접 튜플을 구현할수도 있다.</p>
<pre><code class="c#">  {
      var result = pg.ParseInteger(&quot;40&quot;);
      Console.WriteLine(result.Parsed);
      Console.WriteLine(result.Number);

      (bool success, int n) caller = pg.ParseInteger(&quot;40&quot;);
      Console.WriteLine(caller.success);
      Console.WriteLine(caller.n);

      (bool ret, int num) = pg.ParseInteger(&quot;40&quot;);
      Console.WriteLine(ret);
      Console.WriteLine(num);

      (var _, var _) = pg.ParseInteger(&quot;40&quot;); //2개값 모두 생략
      (var _, var n) = pg.ParseInteger(&quot;40&quot;); //마지막 값만 n으로 받음
  }
  (bool Parsed, int Number) ParseInteger(string text) //Return 타입에 이름 지정
  {
      //생략
      return (result, number)
  }</code></pre>
</li>
</ul>
<h3 id="lambda-메서드-정의-확대"><a href="#lambda-메서드-정의-확대" class="headerlink" title="lambda 메서드 정의 확대"></a>lambda 메서드 정의 확대</h3><ul>
<li>아래의 메서드에대한 lambda 정의가 7.0부터 가능해졌다.<ul>
<li>생성자/소멸자</li>
<li>이벤트 클래스의 add/remove</li>
<li>속성/인덱서의 set</li>
</ul>
</li>
</ul>
<h3 id="지역함수"><a href="#지역함수" class="headerlink" title="지역함수"></a>지역함수</h3><ul>
<li>메서드 내에서만 활용할 수 있는 지역함수 문법이 추가되었다.</li>
<li>익명함수 표기도 가능하며, 단일식이면 람다로도 표현가능하다.</li>
<li>표기는 자유롭지만, c# 컴파일러는 internal 접근자를 가진 메서드로 정의해 타입 내에 자동으로 추가한다.</li>
</ul>
<h3 id="ValueTask-async메서드-반환타입으로-사용자-정의-Task타입을-반환할-수-있게됨"><a href="#ValueTask-async메서드-반환타입으로-사용자-정의-Task타입을-반환할-수-있게됨" class="headerlink" title="ValueTask: async메서드 반환타입으로 사용자 정의 Task타입을 반환할 수 있게됨"></a>ValueTask<t>: async메서드 반환타입으로 사용자 정의 Task타입을 반환할 수 있게됨</t></h3><ul>
<li><p>async 예약어가 붙는 메서드는 반환타입이 void, Task, Task<t> 중에 하나여야한다</t></p>
</li>
<li><p>문제는 메서드 내에서 await호출이 되지 않아 비동기 처리가 필요 없을때도 Task 객체가 생성되어 성능상 불이익이 발생한다.</p>
</li>
<li><p>여기서 반환 타입을 ValueTask<t>형식으로 바꿔주면 비동기 처리를 하지 않을 경우에는 Task 객체 생성이 일어나지 않는다.</t></p>
<pre><code class="c#">  static string _filecontents = string.Empty;
  private static async Task&lt;(string, int)&gt; FileReadAsync(string filePath)
  {
      if (string.IsNullOrEmpty(_filecontents) == false)
              return (_filecontents, Thread.CurrentThread.ManagedThreadId);

      _filecontents = await ReadAllTextAsync(filePath);
      return (_filecontents, Thread.CurrentThread.ManagedThreadId);
  }
</code></pre>
</li>
</ul>
<h3 id="자유로운-throw-사용"><a href="#자유로운-throw-사용" class="headerlink" title="자유로운 throw 사용"></a>자유로운 throw 사용</h3><ul>
<li>throw는 식(expression)이 아닌 문(statement)에 해당한다.</li>
<li>즉 ‘항’의 개념이 아니므로 삼항연산자에 사용되려면 메서드를 별개로 만들어 우회해서 사용해야 했었다.</li>
<li>7.0부터는 직접 사용이 가능하며,<ul>
<li>그렇다해서 모든 구문이 사용한것은 아니고 사용이 안되는 맥락에서는 컴파일 에러를 발생시킨다.</li>
</ul>
</li>
</ul>
<h3 id="리터럴의-가독성-상승을-위한-표현방식-개선"><a href="#리터럴의-가독성-상승을-위한-표현방식-개선" class="headerlink" title="리터럴의 가독성 상승을 위한 표현방식 개선"></a>리터럴의 가독성 상승을 위한 표현방식 개선</h3><ul>
<li>7.0부터 숫자 내의 임의의 위치에 밑줄을 추가할 수 있다.<ul>
<li>10,000,000 와 같은 표현을 위해 int number = 10_000_000 형식으로 표기 가능하다.</li>
</ul>
</li>
<li>숫자뿐만이 아니라 16진수 표현도 가능하다.</li>
</ul>
<h3 id="패턴-매칭-상수-null-참조타입-값타입-var-등…-is-연산"><a href="#패턴-매칭-상수-null-참조타입-값타입-var-등…-is-연산" class="headerlink" title="패턴 매칭(상수, null, 참조타입, 값타입, var 등…): is 연산"></a>패턴 매칭(상수, null, 참조타입, 값타입, var 등…): is 연산</h3><ul>
<li><p>is는 as와 기본적으로 동일한 기능을 수행한다.</p>
</li>
<li><p>차이점은 as는 변수에 캐스팅 결과가 담기지만,</p>
</li>
<li><p>is는 구문자체로는 True/False를 반환하고, 비교 타입 뒤에 변수명을 입력하면 해당 변수에 캐스팅된 값이 할당된다는 차이점이 있다.</p>
<pre><code class="c#">  object obj = new List&lt;string&gt;();
  if(obj is List&lt;string&gt; list)
      list.ForEach(e =&gt; Console.WriteLine(e));

  object[] object = new object[] { 100, null, DateTime.Now, new ArrayList() };
  foreach(object item in objList)
  {
      if (item is 100) {
          //item 사용
      } else if (item is null) { 
          //item 사용
      } else if (item is DateTime dt) {
          //dt 사용
      }
  }</code></pre>
</li>
<li><p>var도 가능하지만 사실상 의미가 없다.</p>
<ul>
<li>단 var 타입뒤에 변수명 반드시 써줘야하며, 이것도 의미가 없으면 언더바(_)로 입력하면된다.</li>
</ul>
</li>
</ul>
<h3 id="패턴-매칭-switch-case-연산"><a href="#패턴-매칭-switch-case-연산" class="headerlink" title="패턴 매칭: switch/case 연산"></a>패턴 매칭: switch/case 연산</h3><ul>
<li>case 예약어 다음에 “[타입] [변수명]”을 넣으면 is 예약어처럼 사용 가능하다</li>
<li>case 구문 뒤에 when 예약어를 추가하면 조건을 한번 더 검사할 수 있다. 예외필터의 when과 사용법이 동일하다.</li>
<li>튜플타입과 같은 복잡한 인자를 받을 때 var와 when 구문을 사용하면 훨씬 간결하게 사용할 수 있다.<pre><code class="c#">  Action&lt;(int, int)&gt; detectZeroOr = (arg) =&gt;
  {
      switch (arg)
      {
          case var r when r.Equals(0, 0):
          case var r1 when r1.Item == 0:
          case var r2 when r2.Item == 0:
              return;
      }
      Console.WriteLine(&quot;both nonzero&quot;)
  }</code></pre>
</li>
</ul>

            </div>
          

    
      <footer class="post-footer">
        <div class="post-tags">
          
            <a href="/tags/c/">c#</a>
          
            <a href="/tags/ref/">ref</a>
          
            <a href="/tags/out/">out</a>
          
            <a href="/tags/lambda/">lambda</a>
          
            <a href="/tags/when/">when</a>
          
            <a href="/tags/is/">is</a>
          
            <a href="/tags/c-7-0/">c#7.0</a>
          
            <a href="/tags/tuple/">tuple</a>
          
            <a href="/tags/valuetask/">ValueTask</a>
          
            <a href="/tags/switch-case/">switch/case</a>
          
        </div>

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/csharp/csharp-2018-12-11-csharp-7-1-tuple-async-is/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">c# 기본서 - c# 7.1: Tuple, ValueTuple, async, is</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/csharp/csharp-2018-12-07-csharp-5-0-asyncawait/">
        <span class="next-text nav-default">c# 기본서 - c# 5.0: async, await</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
    <!--<div style="text-align:center;">
        <button class="btn" id="load-disqus" onclick="disqus.load();">load Disqus review</button>
    </div>-->
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
    2019
    <span class="footer-author">Park Doyeon.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> and <a class="theme-link" href="https://github.com/parkdoyeon">Me</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    

<script type="text/javascript">
  var disqus_shortname = 'parkdoyeon';
  var disqus_identifier = 'csharp/csharp-2018-12-11-csharp-7-0-tupleandreserved/';
  var disqus_url = 'https://parkdoyeon.github.io/csharp/csharp-2018-12-11-csharp-7-0-tupleandreserved/index.html';

  
  var disqus_config = function () {
      this.page.url = disqus_url;
      this.page.identifier = disqus_identifier;
  };
  
  (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
  
  
  // var disqus = {
  //   load : function disqus(){
  //       if(typeof DISQUS !== 'object') {
  //         (function () {
  //         var s = document.createElement('script'); s.async = true;
  //         s.type = 'text/javascript';
  //         s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  //         (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
  //         }());
  //         $('#load-disqus').remove(); ///Delete Button
  //       }
  //   }
  // }

</script>


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script src="/js/src/theme.js?v="></script>
<script src="/js/src/bootstrap.js?v="></script>


    <script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<script src="/js/src/highlight.pack.js?v="></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.7.0/highlightjs-line-numbers.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
  document.querySelectorAll('figure.highlight').forEach((block) => {
    hljs.highlightBlock(block);
  });
});
hljs.initHighlightingOnLoad();
hljs.initLineNumbersOnLoad();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  </body>
</html>
