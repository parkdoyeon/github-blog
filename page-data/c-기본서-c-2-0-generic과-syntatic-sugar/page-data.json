{"componentChunkName":"component---src-templates-post-js","path":"/c-기본서-c-2-0-generic과-syntatic-sugar","result":{"data":{"markdownRemark":{"html":"<h3 id=\"새로운-제네릭-문법-t와-제약조건\"><a href=\"#%EC%83%88%EB%A1%9C%EC%9A%B4-%EC%A0%9C%EB%84%A4%EB%A6%AD-%EB%AC%B8%EB%B2%95-t%EC%99%80-%EC%A0%9C%EC%95%BD%EC%A1%B0%EA%B1%B4\" aria-label=\"새로운 제네릭 문법 t와 제약조건 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>새로운 제네릭 문법 <T>와 제약조건</h3>\n<ul>\n<li>제너릭의 박싱/언박싱 문제를 보완한 새로운 버전의 컬렉션이 2.0에 등장한다. 대표적인 예가 ArrayList -> List<T></li>\n<li><T>에 타입을 지정해주면 CLR이 JIT컴파일 시에 대응되는 타입을 대체해서 코드를 확장한다.</li>\n<li>\n<p>기존에 여러개의 타입인자를 지정해줘야했던 문제도 <T>를 지정하면서 한번에 해결할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">public static void WriteLog&lt;T&gt;(T item)\n{\nstring output = string.Format(&quot;{0}: {1}&quot;, DateTime.Now, item);\n}</code></pre></div>\n</li>\n<li>\n<p>이렇게 여러타입을 매개변수로 받으면 조건을 넣어줘야하는 경우가 있을 수 있다. 그럴땐 Where 예약어를 사용하면 된다.</p>\n<ul>\n<li>T대신 K, V 등을 써서 여러개의 파라미터에 서로 다른 타입을 명시해줄수도 있고, 여기에 where문을 각각 지정줄수도 있다. (590p)</li>\n<li>\n<p>아래의 예시에 있는 인터페이스 상속 조건 말고도 여러 타입을 지정해줄 수 있다.</p>\n<table>\n<thead>\n<tr>\n<th>제약조건</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>where T: U</td>\n<td>U형식 인수에 해당하는 타입이거나 상속받은 클래스만</td>\n</tr>\n<tr>\n<td>where T: struct</td>\n<td>값 형식만</td>\n</tr>\n<tr>\n<td>where T: class</td>\n<td>참조 형식만</td>\n</tr>\n<tr>\n<td>where T: new()</td>\n<td>기본생성자(매개변수가 없는)가 정의된 타입만</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">public static T Max&lt;T&gt;(T item, T item2) where T : IComparable //[, ...] 조건을 여러개 받을 수도 있다\n{\n    if(item1.CompareTo(item2) &gt;= 0)\n        return item1;\n    return item2;\n}</code></pre></div>\n</li>\n</ul>\n</li>\n<li>default 예약어: 제네릭 형식 매개변수로 전달된 값의 초기값을 반환해야하는 경우가 있을 수 있다. 이때 컴파일러가 자동으로 결정할 수 있도록 하는게 default(T) 예약어이다.</li>\n</ul>\n<h3 id=\"yield-returnbreak와-ienumerator\"><a href=\"#yield-returnbreak%EC%99%80-ienumerator\" aria-label=\"yield returnbreak와 ienumerator permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>yield return/break와 IEnumerator</h3>\n<ul>\n<li>\n<p>foreach문법은 IEnumerable, IEnumerator 인터페이스를 구현한 객체를 열거할때 사용할 수 있다.</p>\n<ul>\n<li>\n<p>멤버는 아래와 같다</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">interface IEnumerable\n{\nIEnumerator GetEnumerator();\n}\ninterface IEnumerator\n{\nbool MoveNext(); //다음 요소 위치로 이동, 더 이상 없으면 false 반환\nvoid Reset();       //초기 상태로 바꿈\nObject Current    //현재 위치의 요소를 가져오기\n{\n    get;\n}\n}</code></pre></div>\n</li>\n<li>IEnumerable의 독특한 점은 \"무한집합\"을 표현할 수 있다는 것이다.</li>\n</ul>\n</li>\n<li>\n<p>IEnumerable, IEnumerator를 간편하게 구현하고싶다면 yield 예약어를 사용하면 된다.</p>\n<ul>\n<li>yield return을 사용하면 다음번 해당 메서드를 호출했을때 마지막 yield return 다음 코드 부터 실행한다. (IEnumerator에 Current 멤버가 있는 것을 생각해보면 된다)</li>\n<li>yield break을 사용하면 열거를 끝낼 수 있다. </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"기타\"><a href=\"#%EA%B8%B0%ED%83%80\" aria-label=\"기타 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기타</h3>\n<ul>\n<li>partial 클래스: C#컴파일러는 빌드 시에 '같은 프로젝트'에 있는 partial 클래스를 하나로 모아 단일 클래스로 빌드한다.</li>\n<li>nullable 형식:  System.Nullable<T>은 값이 없는 상태 자체를 표기하기 위한 타입으로, T? 형식으로 간편하게 표기할 수 있다. HasValue와 Value 두 가지 속성을 제공한다.</li>\n<li>\n<p>익명메서드: 이름이 없는 메서드로, 메서드가 일회성으로만 필요할때 편의상 사용된다(syntactic sugar)</p>\n<ul>\n<li>\n<p>delegate 예약어를 사용해 메서드의 코드를 전달한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">delegate int? MyDevide(int a, int b)\nstatic void Main(string[] args)\n{\nMyDivde myFunc = delegate (int a, int b)\n{\n    if (b==0)\n        return null;\n    return a/b;\n}\n}</code></pre></div>\n</li>\n</ul>\n</li>\n</ul>","timeToRead":2,"excerpt":"새로운 제네릭 문법 와 제약조건 제너릭의 박싱/언박싱 문제를 보완한 새로운 버전의 컬렉션이 2.0에 등장한다. 대표적인 예가 ArrayList -> List 에 타입을 지정해주면 CLR이 JIT…","frontmatter":{"title":"c# 기본서 - c# 2.0, Generic과 syntatic sugar","cover":"","date":"2018-12-05T17:42:00.000Z","categories":["C#"],"tags":["c#","c#2.0","IEnumerator","AnonymousMethod","T","Generic","yield","where"]},"fields":{"slug":"/c-기본서-c-2-0-generic과-syntatic-sugar","date":"December 04, 2018"}}},"pageContext":{"slug":"/c-기본서-c-2-0-generic과-syntatic-sugar","nexttitle":"c# 기본서 - AppDomain과 리플렉션","nextslug":"/c-기본서-app-domain과-리플렉션","prevtitle":"c# 기본서 - c# 3.0: Lambda, 확장메서드","prevslug":"/c-기본서-c-3-0-lambda-확장메서드"}}}