{"componentChunkName":"component---src-templates-post-js","path":"/programming-elixir-3-함수","result":{"data":{"markdownRemark":{"html":"<h3 id=\"엘릭서의-함수\"><a href=\"#%EC%97%98%EB%A6%AD%EC%84%9C%EC%9D%98-%ED%95%A8%EC%88%98\" aria-label=\"엘릭서의 함수 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>엘릭서의 함수</h3>\n<p>엘릭서는 같은 이름을 가졌더라도 인자로 받는 파라미터 갯수가 다른 함수를 서로 구분한다. 그러나 코드 작성의 관점에서 혼란을 줄 수 있으므로 이런 상황은 피하는 것이 좋다.</p>\n<h3 id=\"함수의-매칭\"><a href=\"#%ED%95%A8%EC%88%98%EC%9D%98-%EB%A7%A4%EC%B9%AD\" aria-label=\"함수의 매칭 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>함수의 매칭</h3>\n<p>앨릭서는 같은 이름의 함수를 호출할 때 매칭되는 함수를 ‘순서대로’호출한다. 예컨데 다음과 같이 재귀함수를 구현할 때,</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">defmodule Factorial do\n  def of(0), do: 1\n  def of(n), do: n*of(n-1)\nend</code></pre></div>\n<p>첫번째에 해당하는 케이스가 아니면 두번째 of함수를 호출한다.\n만약 Factorial내부의 함수가 <code class=\"language-text\">of(n)</code>이 먼저 등장하는 순서로 구현이 되어있으면, <code class=\"language-text\">f(0)</code>이 절대 도달불가능하므로 컴파일시 경고를 띄운다.</p>\n<h3 id=\"when\"><a href=\"#when\" aria-label=\"when permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>When</h3>\n<p>함수 인자의 validity를 체크할때 사용. 더 명확하게 표현 가능하다.</p>\n<h3 id=\"함수의-기본값\"><a href=\"#%ED%95%A8%EC%88%98%EC%9D%98-%EA%B8%B0%EB%B3%B8%EA%B0%92\" aria-label=\"함수의 기본값 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>함수의 기본값</h3>\n<p><code class=\"language-text\">\\\\</code>를 통해 함수인자의 기본 값 부여가 가능하다</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">iex&gt; def func(p1 \\\\ 1) do: IO inspect p1\n#p1이 없으면 파라미터로 1이 넘어감.</code></pre></div>\n<p>그러나 같은 이름을 갖는 함수의 경우 혼란을 막기 위해 기본값을 사용하는 함수가 먼저 매칭되지 않도록 하자.</p>\n<h3 id=\"defp\"><a href=\"#defp\" aria-label=\"defp permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>defp</h3>\n<p>모듈 내 프라이빗 함수선언은 <code class=\"language-text\">defp</code>로 가능하다.\n그러나 모뉼 내 같은 이름을 가지면서 어떤 함수는 프라이빗하고 어떤 함수는 퍼블릭할 수 없다.</p>\n<h3 id=\"pipe-operator-을-통한-메소드-체이닝\"><a href=\"#pipe-operator-%EC%9D%84-%ED%86%B5%ED%95%9C-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%B2%B4%EC%9D%B4%EB%8B%9D\" aria-label=\"pipe operator 을 통한 메소드 체이닝 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>pipe operator |>을 통한 메소드 체이닝</h3>\n<p>DB커넥션 구문같이 호출 결과를 인자로 받을 때 <code class=\"language-text\">|&gt;</code>를 사용하면 더 깔끔하게 표현가능하다.\n<code class=\"language-text\">|&gt;</code>구문은 왼쪽의 구문 결과값을 인자로 오른쪽 메소드를 호출한다</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">list\n|&gt; sales_tax(2018)\n|&gt; prepare_filing\n#아래와 동일\nprepare_filing(sales_tax(list, 2018))</code></pre></div>\n<p>*주의, 파이프 오퍼레이터 사용시 함수의 경우 반드시 괄호를 사용해야한다.\n파이프 오퍼레이터는 '프로그래밍은 데이터를 변환하는 것'이라는 정의에 맞게, 데이터 변환 과정을 명시적으로 표기할 수 있도록 한다.</p>\n<h3 id=\"module\"><a href=\"#module\" aria-label=\"module permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Module</h3>\n<p>엘릭서에서 모듈 내에 내장된 모듈은 환상이다. 모든 모듈은 최상위 레벨에 존재하며, 마침표는 하위 모듈을 불러오지 않고 네임스페이스로만 동작한다. 가령 Mix.Tasks.Doctest와 Mix라는 두 모듈은 서로 어떤 연관성도 갖지 않는다.</p>\n<h3 id=\"directive\"><a href=\"#directive\" aria-label=\"directive permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Directive</h3>\n<p>import는 불러온 모듈의 이름을 일일히 호명하지 않아도 스코프 안에서 모듈 내 내장된 함수를 사용할 수 있도록 한다.\n<code class=\"language-text\">alias, defmodule, import, def</code>와 같은 derective구문은 <code class=\"language-text\">end</code>를 만날때 까지 해당 스코프 내에서 유효하다.\n<code class=\"language-text\">alias … as</code>를 통해 import하는 모듈의 표현을 단축할 수 있다. <code class=\"language-text\">as</code>를 생략하면 마지막 네임스페이스만 사용하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">defmodule Example do\n  def compile_and_go(source) do\n    alias My.Other.Module.Parser, as: Parser\n    alias My.Other.Module.Runner, as: Runner\n#혹은 \n#    alias My.Other.Module.Parser\n#    alias My.Other.Module.Runner 로도 쓸 수 있다.\n  end\nend</code></pre></div>\n<h3 id=\"모듈의-이름\"><a href=\"#%EB%AA%A8%EB%93%88%EC%9D%98-%EC%9D%B4%EB%A6%84\" aria-label=\"모듈의 이름 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모듈의 이름</h3>\n<p>내부적으로 모듈의 이름은 전부 아톰타입이다. 대문자로 시작하는 모든 이름을 지으면 엘릭서는 자동적으로 Elixir라는 접두어를 붙인다. 때문에 모든 함수는 아톰+점(.)+함수명형태의 아톰이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">iex&gt; is_atom IO\nTrue\niex&gt; to_string IO\n“Elixir.IO&quot;\niex&gt; :”Elixir.IO” === IO\ntrue\niex&gt; :”Elixir.IO”.puts 123\n123\n:ok</code></pre></div>\n<h3 id=\"erlang과-elixir\"><a href=\"#erlang%EA%B3%BC-elixir\" aria-label=\"erlang과 elixir permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>erlang과 elixir</h3>\n<p>언랭 컨벤션은 엘릭서와 다르므로, 언랭 함수 호출시에는 언랭 규칙에 따라 호출하면 된다.\n엘릭서와 달리 언랭은 아톰타입이 소문자로 시작하고 변수가 대문자로 시작한다.</p>","timeToRead":3,"excerpt":"…","frontmatter":{"title":"Programming Elixir 3 - 함수","cover":"","date":"2020-01-27T10:58:08.000Z","categories":["Elixir"],"tags":["elixir","function","functional"]},"fields":{"slug":"/programming-elixir-3-함수","date":"January 26, 2020"}}},"pageContext":{"slug":"/programming-elixir-3-함수","nexttitle":"Programming Elixir 2 - 자료형과 오퍼레이터","nextslug":"/programming-elixir-2-자료형과-오퍼레이터","prevtitle":"Programming Elixir 4 - 타입과 모듈","prevslug":"/programming-elixir-4-타입과-모듈"}}}