{"componentChunkName":"component---src-templates-post-js","path":"/c-기본서-c-3-0-linq","result":{"data":{"markdownRemark":{"html":"<h3 id=\"linq\"><a href=\"#linq\" aria-label=\"linq permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LINQ</h3>\n<ul>\n<li>\n<p>IEnumerable<T>를 인자로 받는다</p>\n<ul>\n<li>IEnumerable<T>, IOrderedEnumerable<TElement>를 상속받아 정의하면 LINQ를 사용할 수 있다</li>\n</ul>\n</li>\n<li>\n<p>IEnumerate<T>, IOrderedEnumerable<TElement>를 반환한다.</p>\n<ul>\n<li>두 요소를 반환하지 않는 형식의 메서드를 사용하면 메서드가 즉시 실행된다.</li>\n</ul>\n</li>\n<li>\n<p>select 예약어: Select 확장 메서드호출하는 또 다른 문법에 불과하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">var all = from person in people\n    select person;\npeople.Select((elem) =&gt; elem );</code></pre></div>\n</li>\n<li>\n<p>orderby: IComparable 인터페이스가 구현된 타입에 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">var all = from person in people\n    orderby person.Age descending //디폴트가 ascending\n    select person;</code></pre></div>\n</li>\n<li>\n<p>group ... by: select ... by와 의미적으로 같으므로 (실제 select ... by는 없음) select가 올 수 없다.</p>\n<ul>\n<li>\n<p>그렇기 때문에 select에서 가능한 형변환 작업이 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">var addrGroup = from person in people\ngroup person by person.Address;</code></pre></div>\n</li>\n</ul>\n<p>//아래와 같이도 가능하다\nvar changedGroup = from person in people\ngroup new { Name = person.Name, Age = person.Age } by person.Address;</p>\n<p>foreach(var itemGroup in addrGroup) //컬렉션 요소 분류\n{\nConsole.WriteLine(itemGroup.Key) </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">foreach(var item in itemGroup) //컬렉션 반환\n    Console.WriteLine(item.Name);</code></pre></div>\n<p>}</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"></code></pre></div>\n</li>\n<li>\n<p>join: 이런게 가능하다 정도만?</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">//만족하는 레코드만 삽입시키는 inner join의 유형\n//on ... equals ...가 사용됐다.\nvar nameToLangList = from person in people\n    join language in languages on person.Name equals language.Name\n\n//누락시키지 않고 전부 삽입하는 outer join의 유형\n//빈값에 대한 후처리\nvar nameToLangAllList = from person in people\n    join language in languages on person.Name equals language.Name into lang\n    from language in lang.DefaultIfEmpty(new MainLanguage())\n    select new { Name=person.Name, Age=person.Age, Language=language.Language }</code></pre></div>\n</li>\n</ul>","timeToRead":1,"excerpt":"LINQ IEnumerable를 인자로 받는다 IEnumerable, IOrderedEnumerable를 상속받아 정의하면 LINQ를 사용할 수 있다 IEnumerate, IOrderedEnumerable…","frontmatter":{"title":"c# 기본서 - c# 3.0: LINQ","cover":"","date":"2018-12-06T11:44:00.000Z","categories":["C#"],"tags":["c#","c#3.0","LINQ"]},"fields":{"slug":"/c-기본서-c-3-0-linq","date":"December 05, 2018"}}},"pageContext":{"slug":"/c-기본서-c-3-0-linq","nexttitle":"c# 기본서 - c# 3.0: Lambda, 확장메서드","nextslug":"/c-기본서-c-3-0-lambda-확장메서드","prevtitle":"c# 기본서 - c# 4.0: dynamic","prevslug":"/c-기본서-c-4-0-dynamic"}}}