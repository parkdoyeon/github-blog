{"componentChunkName":"component---src-templates-post-js","path":"/programming-elixir-2-자료형과-오퍼레이터","result":{"data":{"markdownRemark":{"html":"<h3 id=\"interger\"><a href=\"#interger\" aria-label=\"interger permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Interger</h3>\n<p>언더스코어(_)를 통해 콤마를 대체해서 1000단위를 구분할 수 있다. (편의상 표기할때 사용, 컴파일시 무시됨)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">iex&gt; 123_456_789\n123456789</code></pre></div>\n<p>숫자 앞에 0x, 0o, 0b 등을 써서 16진수, 8진수, 2진수 등을 표기할 수 있음</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">iex&gt; 0x41\n65</code></pre></div>\n<p><code class=\"language-text\">?c</code> 처럼 쓰면 c의 UTF 문자열 코드포인트를 반환한다</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">iex&gt; ?≠ 8800\n8800</code></pre></div>\n<h3 id=\"atom\"><a href=\"#atom\" aria-label=\"atom permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Atom</h3>\n<p>엘릭서에서 등장하는 값 자료형 중 하나.\n값이 곧 이름인 자료형으로, 콜론을 앞에 붙여서 표현하거나, 대문자로 시작하는 단어로 표현한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">iex&gt; Dictionary\nDictionary\niex&gt; is_atom(Dictionary)\nTrue</code></pre></div>\n<p>따라서 같은 이름을 갖는 아톰타임은 어떤 프로그램끼리 만나도 동일한 값으로 취급한다. ex) 내장함수에서 사용하는 :ok</p>\n<h3 id=\"boolean\"><a href=\"#boolean\" aria-label=\"boolean permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Boolean</h3>\n<p>엘릭서에서 nil은 falsy한 값으로 취급한다</p>\n<h3 id=\"tuple\"><a href=\"#tuple\" aria-label=\"tuple permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tuple</h3>\n<p>보통 2-3개 정도의 작은 데이터들을 다룰때 사용. 플래그 된 값들을 표기할때 많이 쓴다.</p>\n<h3 id=\"list\"><a href=\"#list\" aria-label=\"list permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>List</h3>\n<p>엘릭서의 list는 중심기능으로서,  array가 아닌 linked list이다.\n따라서 array와 달리 재귀적으로 사용되며, 암시적으로 전체를 순회하며 사용되는 array와 달리 선언적인 함수형 언어에 더 적합한 자료형이다.\n데이터 수정시 변형하지 않고 포인터를 활용한다.\nkeyword lists: 튜플형 인자를 사용하여 Key-value페어 형식으로도 표현가능하다. 함수의 인자로 받을때는 브라켓과 리스트 꺽쇄도 제거 하고 표현 할 수 있다.</p>\n<blockquote>\n<p>The chances are very good that your current language has arrays. They’re probably one of your go-to data structures. You like being able to say “go get the nth element.”</p>\n</blockquote>\n<blockquote>\n<p>But arrays are a data structure suited more to imperative programming, because you must explicitly iterate over them, using an external index. And they are prone to off-by-one errors.</p>\n</blockquote>\n<blockquote>\n<p>On the other hand, lists are a recursive data structure, and turn out to be well suited to a functional or declarative style.</p>\n</blockquote>\n<blockquote>\n<p>It’s a change of perspective that can be hard to make. Stick at it, because once you’re comfortable with lists, you won’t want to go back.</p>\n</blockquote>\n<blockquote>\n<p>To show you some of the power of lists, we need to cover just one more language topic: pattern matching. That’s what the next chapter is about</p>\n</blockquote>\n<h3 id=\"map\"><a href=\"#map\" aria-label=\"map permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Map</h3>\n<p>리스트와 달리 중복된 키값을 허용하지 않는 자료형. 따라서 value접근하는 방법이 하나다. 서로 다른 자료형을 가진 key값을 허용한다. 예컨데 key값으로 아톰이나 튜플도 가능.\n아톰 키값의 경우 map[:key]와 같이 접근하면 키값이 없으면 nil이 반환되지만, dot notation(map.key)의 경우 no matching keys 익셉션이 발생한다.\nkey값을 0부터 순차적으로 커지는 숫자값으로 지정해 array처럼 구현하기도 할 수 있다. 엘릭서에서 pure array가 있다면 그것보다는 못하겠지만, reasonable한 size의 콜렉션이라면 O(1)의 빅오를 가지며 나쁘지 않은 성능을 보인다고한다.</p>\n<h3 id=\"with\"><a href=\"#with\" aria-label=\"with permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>With</h3>\n<p><code class=\"language-text\">with … do … end</code> 형식으로 사용\n함수와 같은 구문형식을 갖기 때문에 첫번째 arg는 꼭 <code class=\"language-text\">with</code>옆에 위치시키거나 괄호로 감싸줘야한다.\n<code class=\"language-text\">with</code>과 <code class=\"language-text\">do</code> 구문 사이에 로컬스코프 생성\n패턴매칭에 실패할때 실패 결과를 다룰 수 있게 해줌\n<code class=\"language-text\">=</code>대신 <code class=\"language-text\">&lt;-</code> 사용하므로써 예외 상황 발생시 nil처리\ndo와 같은 라인에 작성하면 end 쓰지 않고 숏컷으로 작성할 수 있다</p>\n<h3 id=\"-operator\"><a href=\"#-operator\" aria-label=\" operator permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>&#x26; Operator</h3>\n<p>두가지 의미를 갖는다.</p>\n<p>첫째, 함수표현 다음에 나타나는 표현식을 가리키는 숏컷\nex) <code class=\"language-text\">fn p1, p2 -&gt; p1+p2</code>은 <code class=\"language-text\">&amp;(&amp;1+&amp;2)</code>와 같음</p>\n<p>둘째, 문자식과 함께 사용되는 연산자를 가리킨다</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">iex&gt; s = &amp;”bacon and #{&amp;1}”\n#Function&lt;6.99386804/1 in :erl_eval.expr/5&gt;\niex&gt; s.(“custard”)\n“bacon and custard&quot;</code></pre></div>","timeToRead":3,"excerpt":"Interger 언더스코어(_)를 통해 콤마를 대체해서 1000단위를 구분할 수 있다. (편의상 표기할때 사용, 컴파일시 무시됨) 숫자 앞에 0x, 0o, 0b 등을 써서 16진수, 8진수, 2진수 등을 표기할 수 있음  처럼 쓰면 c의 UTF…","frontmatter":{"title":"Programming Elixir 2 - 자료형과 오퍼레이터","cover":"","date":"2020-01-24T10:53:30.000Z","categories":["Elixir"],"tags":["elixir"]},"fields":{"slug":"/programming-elixir-2-자료형과-오퍼레이터","date":"January 23, 2020"}}},"pageContext":{"slug":"/programming-elixir-2-자료형과-오퍼레이터","nexttitle":"Programming Elixir 1 - 원리","nextslug":"/programming-elixir-1-원리","prevtitle":"Programming Elixir 3 - 함수","prevslug":"/programming-elixir-3-함수"}}}