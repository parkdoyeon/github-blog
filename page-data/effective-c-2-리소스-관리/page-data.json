{"componentChunkName":"component---src-templates-post-js","path":"/effective-c-2-리소스-관리","result":{"data":{"markdownRemark":{"html":"<h3 id=\"net-리소스-관리의-이해-finalizeridisposable\"><a href=\"#net-%EB%A6%AC%EC%86%8C%EC%8A%A4-%EA%B4%80%EB%A6%AC%EC%9D%98-%EC%9D%B4%ED%95%B4-finalizeridisposable\" aria-label=\"net 리소스 관리의 이해 finalizeridisposable permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>.NET 리소스 관리의 이해 finalizer/IDisposable</h3>\n<ol>\n<li>닷넷은 가비지 수집기가 있기 때문에 개발자가 메모리 해제/누수와 같은 문제를 직접적으로 처리할 필요가 없다.</li>\n<li>그러나 비관리 리소스의 경우 관리가 필요하며, 이를 위해 finalizer와 IDisposable 라는 두가지 메커니즘을 제공한다. </li>\n<li>\n<p>finalizer의 경우 가비지로 간주된 이후에도 메모리 점유시간이 길어져(언제 해제될지도 알 수 없다) 둘 중 IDisposable이 더 권장된다</p>\n<ul>\n<li>가바지로 간주된 객체는 다음 가비지 수집세대에서 삭제되지만</li>\n<li>finalizer를 갖고있는 객체는 가비지로 판단되더라도 finalizer를 호출하기 전까지 공간이 해제가 안된다.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"할당구문보다-멤버-초기화-구문이-좋다\"><a href=\"#%ED%95%A0%EB%8B%B9%EA%B5%AC%EB%AC%B8%EB%B3%B4%EB%8B%A4-%EB%A9%A4%EB%B2%84-%EC%B4%88%EA%B8%B0%ED%99%94-%EA%B5%AC%EB%AC%B8%EC%9D%B4-%EC%A2%8B%EB%8B%A4\" aria-label=\"할당구문보다 멤버 초기화 구문이 좋다 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>할당구문보다 멤버 초기화 구문이 좋다.</h3>\n<ul>\n<li>생성자에서 초기화 코드를 누락하는 경우가 많으므로 변수를 선언하는 곳에서 초기화를 해주는 것이 좋다.</li>\n<li>초기화를 하지 않으면 예외가 발생할 위험이 있기 때문이다.</li>\n<li>\n<p>다만 초기화가 필요없는 경우가 있는데, 다음과 같다.</p>\n<ol>\n<li>null이나 0으로 초기화를 하는 경우</li>\n<li>저수준에서 CPU 명령이 메모리블록을 0으로 설정하기때문.</li>\n<li>\n<p>아래 코드는 동일한 0 초기화 구문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">{\n  MyValType myVal1;\n  MyValType myVal2 = new MyValType();\n}</code></pre></div>\n</li>\n<li>객체를 생성하는 방식이 다를경우 ex) list 객체의 size를 생성자마자 달리 설정하는 것</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"정적-클래스-멤버를-올바르게-초기화하라\"><a href=\"#%EC%A0%95%EC%A0%81-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A9%A4%EB%B2%84%EB%A5%BC-%EC%98%AC%EB%B0%94%EB%A5%B4%EA%B2%8C-%EC%B4%88%EA%B8%B0%ED%99%94%ED%95%98%EB%9D%BC\" aria-label=\"정적 클래스 멤버를 올바르게 초기화하라 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정적 클래스 멤버를 올바르게 초기화하라</h3>\n<ul>\n<li>정적생성자는 타입 내에 정의된 모든 변수/메서드/속성에 접근하기전에 최초로 접근하는 메서드이다.</li>\n<li>\n<p>복잡한 초기화가 이뤄지는 경우 그 대안으로 사용되기도 한다.</p>\n<ul>\n<li>가령 일반적인 멤버초기화는 예외발생 가능성이 있으면 잡기가 어려운데, 정적생성자의 catch 구문을 통해 복구를 시도할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>때문에 private 메서드 사용등의 잘못된 초기화에 유의해야한다</p>\n<ol>\n<li>만일 잘못된 초기화가 이뤄지면 CLR 단계에서 초기화 익셉션이 발생하며,</li>\n<li>만약 예외가 발생할 가능성이 있는 정적생성자의 예외를 호출부에서 catch로 잡아버리면 해당 AppDomain이 unload하지 않는 한 해당 객체 생성이 불가능하다.</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"초기화가-중복되는-것을-최소화-하라\"><a href=\"#%EC%B4%88%EA%B8%B0%ED%99%94%EA%B0%80-%EC%A4%91%EB%B3%B5%EB%90%98%EB%8A%94-%EA%B2%83%EC%9D%84-%EC%B5%9C%EC%86%8C%ED%99%94-%ED%95%98%EB%9D%BC\" aria-label=\"초기화가 중복되는 것을 최소화 하라 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>초기화가 중복되는 것을 최소화 하라</h3>\n<ul>\n<li>\n<p>생성자를 초기화하는 구문을 두는 방법은 크게 두가지가 있다.</p>\n<ol>\n<li>다양한 변수를 인자로 받는 생성자 오버로딩 + 초기화 할당 메서드 호출</li>\n<li>기본값을 매개변수로 하는 생성자 작성 + this(params) 혹은 base(params) 호출 구문을 통해 상속</li>\n</ol>\n</li>\n<li>\n<p>여기서 두번쨰 방법을 사용하는 것이 좋다.</p>\n<ul>\n<li>전자의 방식을 사용할 경우 생성자 초기화 후에 다시 재 할당이 이뤄지므로 가비지가 생성되며</li>\n<li>readonly 예약어가 적용된 변수는 메서드에서 초기화가 불가능하다.</li>\n<li>또한 코드가 멤버가 많을수록 오버로드의 경우의 수가 많아져 코드가 장황해질 수 있다</li>\n</ul>\n</li>\n<li>\n<p>참고) 초기화 우선순위</p>\n<ol>\n<li>정적변수 저장공간 0으로 초기화 -> 변수 초기화</li>\n<li>베이스 클래스의 정적 생성자 수행</li>\n<li>정적 생성자 수행</li>\n<li>인스턴스 변수 저장공간 0으로 초기화 -> 변수 초기화</li>\n<li>베이스 클래스의 인스턴스 생성자 수행</li>\n<li>인스턴스 생성자 수행</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"불필요한-객체를-만들지-말라\"><a href=\"#%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%A7%80-%EB%A7%90%EB%9D%BC\" aria-label=\"불필요한 객체를 만들지 말라 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>불필요한 객체를 만들지 말라</h3>\n<ul>\n<li>자주 사용되는 지역변수의 경우 멤버 변수로 선언하고 사용해야한다.</li>\n<li>string 객체의 경우 문자열이 추가될때마다 string 객체가 다시 생성되므로 StringBuilder를 사용할것을 권장한다.</li>\n</ul>\n<h3 id=\"생성자-내에서는-절대로-가상함수-호출을-하지-말라더-고민해볼것\"><a href=\"#%EC%83%9D%EC%84%B1%EC%9E%90-%EB%82%B4%EC%97%90%EC%84%9C%EB%8A%94-%EC%A0%88%EB%8C%80%EB%A1%9C-%EA%B0%80%EC%83%81%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C%EC%9D%84-%ED%95%98%EC%A7%80-%EB%A7%90%EB%9D%BC%EB%8D%94-%EA%B3%A0%EB%AF%BC%ED%95%B4%EB%B3%BC%EA%B2%83\" aria-label=\"생성자 내에서는 절대로 가상함수 호출을 하지 말라더 고민해볼것 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>생성자 내에서는 절대로 가상함수 호출을 하지 말라(더 고민해볼것)</h3>\n<ul>\n<li>런타임에서는 멤버변수가 초기화 된 다음에 생성자가 수행되는것이 전제되므로, 멤버변수를 사용하는 가상함수가 null 포인터 예외를 방지하기위해 일관성이 없어질 확률(즉 가상메서드가 구현된 메서드를 호출할 위험)이 있다.</li>\n<li>이를 극복하려면 베이스 클래스에서 추상함수를 선언하고 파생클래스에서 오버라이드 하면된다. 그러나 </li>\n</ul>\n<h3 id=\"표준-dispose패턴을-구현하라\"><a href=\"#%ED%91%9C%EC%A4%80-dispose%ED%8C%A8%ED%84%B4%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%98%EB%9D%BC\" aria-label=\"표준 dispose패턴을 구현하라 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>표준 Dispose패턴을 구현하라</h3>\n<ul>\n<li>\n<p>Dispose 패턴 구현시에 인터페이스 상속을 받는 클래스 멤버중 비관리 리소스가 있으면, 반드시 finalizer를 구현해야한다.</p>\n<ol>\n<li>이용자가 비관리 리소스 정리를 하지 못하는 경우를 대비하기 위한 방어적 코딩이다.</li>\n<li>하지만 멤버에 비관리리소스가 없다면 절대 사용하지 말아야한다.</li>\n</ol>\n</li>\n<li>Dispose나 finalizer에서 다른 작업을 수행하면 GC도, Dispose나 finalizer도 닿지 못하는 객체가 생길 수 있다. 이미 정리된 리소스라고 판단되기 때문이다.</li>\n</ul>","timeToRead":4,"excerpt":".NET 리소스 관리의 이해 finalizer/IDisposable 닷넷은 가비지 수집기가 있기 때문에 개발자가 메모리 해제/누수와 같은 문제를 직접적으로 처리할 필요가 없다. 그러나 비관리 리소스의 경우 관리가 필요하며, 이를 위해 finalizer…","frontmatter":{"title":"effective c# - 2. 리소스 관리","cover":"","date":"2018-12-18T16:41:00.000Z","categories":["C#"],"tags":["effectivec#","c#","finalizer","IDisposable","virtual","constructor"]},"fields":{"slug":"/effective-c-2-리소스-관리","date":"December 17, 2018"}}},"pageContext":{"slug":"/effective-c-2-리소스-관리","nexttitle":"effective c# - 1. 언어요소","nextslug":"/effective-c-1-언어요소","prevtitle":"effective c# - 3. 제네릭 활용","prevslug":"/effective-c-3-제네릭-활용"}}}