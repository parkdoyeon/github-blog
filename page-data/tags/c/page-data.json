{"componentChunkName":"component---src-templates-tag-js","path":"/tags/c/","result":{"data":{"allMarkdownRemark":{"totalCount":24,"edges":[{"node":{"fields":{"slug":"/effective-c-4-linq-활용","date":"January 23, 2019"},"excerpt":"…","timeToRead":3,"frontmatter":{"title":"effective c# - 4. LINQ 활용","tags":["effectivec#","c#","linq","enumerator","yield"],"cover":"","date":"2019-01-24T15:05:00.000Z","categories":["C#"]}}},{"node":{"fields":{"slug":"/effective-c-3-제네릭-활용","date":"January 02, 2019"},"excerpt":"반드시 필요한 제약조건만 설정하라 제너릭 타입을 활용할때 타입 조건을 넣고싶다면 제약조건 예약어 where를 사용하는 것이 좋다 그러나 기본값을 할당하는데 있어서 default()와 new()는 분명한 차이가 있으므로, 제약조건에 new…","timeToRead":7,"frontmatter":{"title":"effective c# - 3. 제네릭 활용","tags":["effectivec#","c#"],"cover":"","date":"2019-01-03T12:19:00.000Z","categories":["C#"]}}},{"node":{"fields":{"slug":"/effective-c-1-언어요소","date":"December 17, 2018"},"excerpt":"지역변수를 선언할때는 var를 사용하는 것이 낫다 c#은 익명함수를 지원하면서 타입을 암시적으로 선언하는 방법을 제공한다. 정확한 타입을 알지 못하는 상태에서 명시적으로 선언할경우 득보다 실이 많다 예1 잘못된 형변환: IEnumerable…","timeToRead":4,"frontmatter":{"title":"effective c# - 1. 언어요소","tags":["effectivec#","c#","is","as","delegate","var"],"cover":"","date":"2018-12-18T16:41:00.000Z","categories":["C#"]}}},{"node":{"fields":{"slug":"/effective-c-2-리소스-관리","date":"December 17, 2018"},"excerpt":".NET 리소스 관리의 이해 finalizer/IDisposable 닷넷은 가비지 수집기가 있기 때문에 개발자가 메모리 해제/누수와 같은 문제를 직접적으로 처리할 필요가 없다. 그러나 비관리 리소스의 경우 관리가 필요하며, 이를 위해 finalizer…","timeToRead":4,"frontmatter":{"title":"effective c# - 2. 리소스 관리","tags":["effectivec#","c#","finalizer","IDisposable","virtual","constructor"],"cover":"","date":"2018-12-18T16:41:00.000Z","categories":["C#"]}}},{"node":{"fields":{"slug":"/c-기본서-c-4-0-dynamic","date":"December 06, 2018"},"excerpt":"4.0 주요변화 이전까지는 닷넷 1.0~3.5용으로 빌드되는 모든 어셈블리가 GAC(Global Assembly Cache)에 추가되는 경우 단일하게 였지만 4.0부터는로 변경되었다. 같은동작을 하는 어셈블리를 .NET 2.0, .NET 4.…","timeToRead":2,"frontmatter":{"title":"c# 기본서 - c# 4.0: dynamic","tags":["c#","c#4.0","dynamic","reflection"],"cover":"","date":"2018-12-07T10:42:00.000Z","categories":["C#"]}}},{"node":{"fields":{"slug":"/c-기본서-c-6-0-간편표기법","date":"December 06, 2018"},"excerpt":"6.0 주요변화 간편 표기법정도의 변화가 있었다. 때문에 빌드할때는 c# 6.0이 필요하지만 빌드 결과를 실행하기위해선 .NET framework 2.0(c# 2.…","timeToRead":4,"frontmatter":{"title":"c# 기본서 - c# 6.0: 간편표기법","tags":["c#","c#6.0","lambda","using","questionmark",null,"dictionary","when","task"],"cover":"","date":"2018-12-07T12:06:00.000Z","categories":["C#"]}}},{"node":{"fields":{"slug":"/c-기본서-c-5-0-async-await","date":"December 06, 2018"},"excerpt":"호출자 정보 c/c++에서 갖고오는 , 와 같은 매크로 상수를 불러올 수 있게됐다. c#에서는 함수 파라미터에 attribute 형식으로 입력하면 된다. 특성 설명 CallerMemberName…","timeToRead":2,"frontmatter":{"title":"c# 기본서 - c# 5.0: async, await","tags":["c#","c#5.0","async","await","Task","Task<TResult>","호출자정보"],"cover":"","date":"2018-12-07T12:06:00.000Z","categories":["C#"]}}},{"node":{"fields":{"slug":"/c-기본서-c-7-1-tuple-value-tuple-async-is","date":"December 06, 2018"},"excerpt":"defalut 리터럴 형식 추가 2.0에 추가된 default는 (T)를 인자로 받았다. 문자 그대로 T를 인자로 받으면 컴파일시 기본값을 추측하는데, 7.0부터 어차피 타입추론이 이뤄지므로 지정이 필요없다고 판단하고 리터럴로 사용하게 됐다. Main…","timeToRead":2,"frontmatter":{"title":"c# 기본서 - c# 7.1: Tuple, ValueTuple, async, is","tags":["c#","c#7.1","default","ValueTuple","async","is"],"cover":"","date":"2018-12-07T12:06:00.000Z","categories":["C#"]}}},{"node":{"fields":{"slug":"/c-기본서-c-7-0-예약어와-value-task-value-tuple","date":"December 06, 2018"},"excerpt":"7.0 주요변화 c# 7.0출시시 닷넷 버전은 4.6.2였다, 현재 7.0에 대응되는 프레임워크는 4.7이다.  타입이 추가되었다. 그러나 4.6.2 닷넷 프레임워크에는 없으므로 nuget…","timeToRead":7,"frontmatter":{"title":"c# 기본서 - c# 7.0: 예약어와 ValueTask/ValueTuple","tags":["c#","c#7.0","tuple","out","ref","lambda","ValueTask","is","when","switch/case"],"cover":"","date":"2018-12-07T12:06:00.000Z","categories":["C#"]}}},{"node":{"fields":{"slug":"/c-기본서-c-3-0-linq","date":"December 05, 2018"},"excerpt":"LINQ IEnumerable를 인자로 받는다 IEnumerable, IOrderedEnumerable를 상속받아 정의하면 LINQ를 사용할 수 있다 IEnumerate, IOrderedEnumerable…","timeToRead":1,"frontmatter":{"title":"c# 기본서 - c# 3.0: LINQ","tags":["c#","c#3.0","LINQ"],"cover":"","date":"2018-12-06T11:44:00.000Z","categories":["C#"]}}},{"node":{"fields":{"slug":"/c-기본서-c-3-0-lambda-확장메서드","date":"December 05, 2018"},"excerpt":"Lambda Expression 람다 대수는 수학에서 함수를 표기하는 방식에서 착안했다. 프로그래밍에서는 두가지 의미를 갖는다. 코드로서 람다: 익명메서드의 간편표기법 가령 수학에서 f(x, y) = x + y인 식을 람다로 치면 (x, y) => x…","timeToRead":2,"frontmatter":{"title":"c# 기본서 - c# 3.0: Lambda, 확장메서드","tags":["c#","c#3.0","Lambda","extensionMethod","this"],"cover":"","date":"2018-12-06T10:03:00.000Z","categories":["C#"]}}},{"node":{"fields":{"slug":"/c-기본서-c-2-0-generic과-syntatic-sugar","date":"December 04, 2018"},"excerpt":"새로운 제네릭 문법 와 제약조건 제너릭의 박싱/언박싱 문제를 보완한 새로운 버전의 컬렉션이 2.0에 등장한다. 대표적인 예가 ArrayList -> List 에 타입을 지정해주면 CLR이 JIT…","timeToRead":2,"frontmatter":{"title":"c# 기본서 - c# 2.0, Generic과 syntatic sugar","tags":["c#","c#2.0","IEnumerator","AnonymousMethod","T","Generic","yield","where"],"cover":"","date":"2018-12-05T17:42:00.000Z","categories":["C#"]}}},{"node":{"fields":{"slug":"/c-기본서-app-domain과-리플렉션","date":"December 02, 2018"},"excerpt":"응용프로그램 도메인(App Domain) 닷넷 응용프로그램은 EXE 프로세스로 실행되고 내부의 CLR에 의해 응용프로그램 도메인(App Domain…","timeToRead":1,"frontmatter":{"title":"c# 기본서 - AppDomain과 리플렉션","tags":["c#","bcl","dll","AppDomain","Reflection"],"cover":"","date":"2018-12-03T16:39:00.000Z","categories":["C#"]}}},{"node":{"fields":{"slug":"/c-기본서-데이터베이스","date":"December 02, 2018"},"excerpt":"데이터 자료형 문자열 데이터형에서 'n' 접두사가 붙은 것은 유니코드 문자(UCS-2)를 담는 것을 의미한다 가령 char(10)은 영문10자, 한글5자라면, nchar(10)은 영문10자, 한글 10자를 표현할 수 있다. 문자열 데이터형에서 'var…","timeToRead":2,"frontmatter":{"title":"c# 기본서 - 데이터베이스","tags":["c#","bcl","database","CRUD","POCO"],"cover":"","date":"2018-12-03T16:39:00.000Z","categories":["C#"]}}},{"node":{"fields":{"slug":"/c-기본서-bcl-비동기-호출","date":"November 29, 2018"},"excerpt":"비동기 호출 일반적으로 동기호출을 Blocking 호출이라고 한다. 동기호출을 하면 해당 스레드는 아무것도 수행하지 못한다. 예시로 disk I/O…","timeToRead":2,"frontmatter":{"title":"c# 기본서 - BCL: 비동기 호출","tags":["c#","bcl","thread","async"],"cover":"","date":"2018-11-30T12:02:00.000Z","categories":["C#"]}}},{"node":{"fields":{"slug":"/c-기본서-네트워크","date":"November 29, 2018"},"excerpt":"비동기 호출 프로토콜: 어떤 절차를 거쳐서 통신을 주고받을것이냐에 대한 규칙 현재 인터넷에서 가장 많이사용하는 규칙은 tcp/ip이다. IPv4: Internet Protocol의 4번째버전에 해당하는 기술 이미 주소가 바닥났지만 하나의 IP…","timeToRead":3,"frontmatter":{"title":"c# 기본서 - 네트워크","tags":["c#","bcl","network","tcp","udp","ip"],"cover":"","date":"2018-11-30T15:13:00.000Z","categories":["C#"]}}},{"node":{"fields":{"slug":"/c-기본서-bcl-thread-monitor-lock-interlocked","date":"November 26, 2018"},"excerpt":"Thread Context 스레드는 CPU의 명령어 실행과 관련된 정보를 보관한다. 이를 스레드 문맥이라고 한다. 즉, 언제 실행하고 또 이전에 얼만큼 실행했는지를 기억하는 것이다. 초기에는 단일 CPU였기 떄문에 다중스레드는 1개의 CPU…","timeToRead":4,"frontmatter":{"title":"c# 기본서 - BCL: Thread, Monitor, Lock, Interlocked","tags":["c#","bcl","thread","monitor","lock","interlocked"],"cover":"","date":"2018-11-27T00:14:00.000Z","categories":["C#"]}}},{"node":{"fields":{"slug":"/c-기본서-bcl-file-direcotry-path","date":"November 20, 2018"},"excerpt":"System.IO.FileStream MemoryStream은 메모리에 할당된 바이트배열을 읽고 쓰지만 FileStream은 디스크 파일을 읽고 쓴다 읽을때는 StreamWriter, 가독성을 무시하고 효율적으로 기록을 하려면 BinaryWriter…","timeToRead":1,"frontmatter":{"title":"c# 기본서 - BCL: File, Direcotry, Path","tags":["c#","bcl","FileStream","File","Directory","Path"],"cover":"","date":"2018-11-21T23:18:00.000Z","categories":["C#"]}}},{"node":{"fields":{"slug":"/c-기본서-bcl-시간계산-collection-문자열처리-직렬화와-stream","date":"November 13, 2018"},"excerpt":"UTC, GMT 영국 기준 동쪽인 곳은 시간이 증가하므로 대한민국은 GMT +9이다. 이 시간을 Korean Standard Time이라고 한다. 세계협정시(Universal Time Coordinated)가 GMT…","timeToRead":3,"frontmatter":{"title":"c# 기본서 - BCL: 시간계산, Collection, 문자열처리, 직렬화와 Stream","tags":["c#","bcl","DateTime","collection","encoding","regex","string","serialization","stream"],"cover":"","date":"2018-11-14T23:10:00.000Z","categories":["C#"]}}},{"node":{"fields":{"slug":"/c-기본서-빌드환경과-gc-힙과-스택","date":"November 05, 2018"},"excerpt":"전처리기 지시문 #if #endif 잔처리기를 사용하면 컴파일시 적용되는 구문을 분기처리할 수 있다. DEBUG와 TRACE상수의 경우 빌드 옵션에서 세팅할수 있고, 별도로 세팅을 하고싶으면 아래대로 하면 된다 Project Properties…","timeToRead":3,"frontmatter":{"title":"c# 기본서 - 빌드환경과 GC, 힙과 스택","tags":["c#","build","GC","Stack","Heap","Attribute","예약어","dll","자원수거"],"cover":"","date":"2018-11-06T23:10:00.000Z","categories":["C#"]}}},{"node":{"fields":{"slug":"/c-기본서-멤버별-유형확장","date":"October 24, 2018"},"excerpt":"readonly, const 둘다 객체의 내부값 변경불가 그러나 const는 byte, int, string 등 기본 자료형에 한해서 적용가능 const는 선언과 함께 값이 대입되어야함. 즉, 생성자에서 접근할 수 없다. const…","timeToRead":1,"frontmatter":{"title":"c# 기본서 - 멤버별 유형확장","tags":["c#","객체지향","readonly","const","event","indexer"],"cover":"","date":"2018-10-25T22:10:00.000Z","categories":["C#"]}}},{"node":{"fields":{"slug":"/c-기본서-구조체-예약어-enum","date":"October 18, 2018"},"excerpt":"Tight Coupling, Loose Coupling…","timeToRead":1,"frontmatter":{"title":"c# 기본서 - 구조체, 예약어, Enum","tags":["c#","객체지향","기본","struct","ref","out","coupling","enum"],"cover":"","date":"2018-10-19T21:10:00.000Z","categories":["C#"]}}},{"node":{"fields":{"slug":"/c-기본서-다형성","date":"October 14, 2018"},"excerpt":"중첩클래스 멤버와 같이 취급되므로 접근제한자 생략되면 private가 된다 cf. 클래스는 원래 접근제한자 없으면 internal virtual과 override virtual…","timeToRead":1,"frontmatter":{"title":"c# 기본서 - 다형성","tags":["c#","객체지향","기본","delegate","class","interface"],"cover":"","date":"2018-10-15T21:10:00.000Z","categories":["C#"]}}},{"node":{"fields":{"slug":"/c-기본서-객체지향","date":"October 13, 2018"},"excerpt":"Getter Setter를 사용하면 좋은 이유 필드를 직접 호출하여 값변경을 하면 제약을 두고싶을때(ex 환율계산, 값 범위 제한 등 ) 필드값이 사용되는 지점에 직접 가서 변경해야한다. Get/Set…","timeToRead":2,"frontmatter":{"title":"c# 기본서 - 객체지향","tags":["c#","객체지향","기본","base","getter","setter","as","static"],"cover":"","date":"2018-10-14T18:10:00.000Z","categories":["C#"]}}}]}},"pageContext":{"tag":"c#"}}}