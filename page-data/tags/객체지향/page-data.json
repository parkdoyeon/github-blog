{"componentChunkName":"component---src-templates-tag-js","path":"/tags/객체지향/","result":{"data":{"allMarkdownRemark":{"totalCount":4,"edges":[{"node":{"fields":{"slug":"/c-기본서-멤버별-유형확장","date":"October 24, 2018"},"excerpt":"readonly, const 둘다 객체의 내부값 변경불가 그러나 const는 byte, int, string 등 기본 자료형에 한해서 적용가능 const는 선언과 함께 값이 대입되어야함. 즉, 생성자에서 접근할 수 없다. const…","timeToRead":1,"frontmatter":{"title":"c# 기본서 - 멤버별 유형확장","tags":["c#","객체지향","readonly","const","event","indexer"],"cover":"","date":"2018-10-25T22:10:00.000Z","categories":["C#"]}}},{"node":{"fields":{"slug":"/c-기본서-구조체-예약어-enum","date":"October 18, 2018"},"excerpt":"Tight Coupling, Loose Coupling…","timeToRead":1,"frontmatter":{"title":"c# 기본서 - 구조체, 예약어, Enum","tags":["c#","객체지향","기본","struct","ref","out","coupling","enum"],"cover":"","date":"2018-10-19T21:10:00.000Z","categories":["C#"]}}},{"node":{"fields":{"slug":"/c-기본서-다형성","date":"October 14, 2018"},"excerpt":"중첩클래스 멤버와 같이 취급되므로 접근제한자 생략되면 private가 된다 cf. 클래스는 원래 접근제한자 없으면 internal virtual과 override virtual…","timeToRead":1,"frontmatter":{"title":"c# 기본서 - 다형성","tags":["c#","객체지향","기본","delegate","class","interface"],"cover":"","date":"2018-10-15T21:10:00.000Z","categories":["C#"]}}},{"node":{"fields":{"slug":"/c-기본서-객체지향","date":"October 13, 2018"},"excerpt":"Getter Setter를 사용하면 좋은 이유 필드를 직접 호출하여 값변경을 하면 제약을 두고싶을때(ex 환율계산, 값 범위 제한 등 ) 필드값이 사용되는 지점에 직접 가서 변경해야한다. Get/Set…","timeToRead":2,"frontmatter":{"title":"c# 기본서 - 객체지향","tags":["c#","객체지향","기본","base","getter","setter","as","static"],"cover":"","date":"2018-10-14T18:10:00.000Z","categories":["C#"]}}}]}},"pageContext":{"tag":"객체지향"}}}