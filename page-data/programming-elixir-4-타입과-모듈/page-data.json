{"componentChunkName":"component---src-templates-post-js","path":"/programming-elixir-4-타입과-모듈","result":{"data":{"markdownRemark":{"html":"<h3 id=\"리스트와-재귀\"><a href=\"#%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%99%80-%EC%9E%AC%EA%B7%80\" aria-label=\"리스트와 재귀 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리스트와 재귀</h3>\n<h4 id=\"heads-and-tails\"><a href=\"#heads-and-tails\" aria-label=\"heads and tails permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Heads and Tails</h4>\n<p>엘릭서는 join operator인 파이프 연산자로 머리와 나머지(tail)를 나눌 수 있다.\n파이프 연산자와 재귀를 통해 길이 함수를 간단하게 구현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">defmodule MyList do\n  def len([]), do: 0\n  def len([_head|tail]), do: 1 + len(tail)\n#head는 함수내에서 사용하는 일이 없으므로 컴파일시 경고를 띄우지않게 언더스코어를 넣는다.</code></pre></div>\n<h4 id=\"문자열과-리스트\"><a href=\"#%EB%AC%B8%EC%9E%90%EC%97%B4%EA%B3%BC-%EB%A6%AC%EC%8A%A4%ED%8A%B8\" aria-label=\"문자열과 리스트 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문자열과 리스트</h4>\n<p>엘릭서에서 문자열은 우리가 알고있는 일련의 단어들의 조합과 쿼테이션마크이면서,\n리스트로 표기된 코드포인트의 값들이다. 후자의 경우 iEX에서 '리스트의 모든 값이 문자열로 표현가능한지' 여부에 따라 구분한다. (heuristically; trial and error)</p>\n<h3 id=\"다른-타입들\"><a href=\"#%EB%8B%A4%EB%A5%B8-%ED%83%80%EC%9E%85%EB%93%A4\" aria-label=\"다른 타입들 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다른 타입들</h3>\n<h4 id=\"structs\"><a href=\"#structs\" aria-label=\"structs permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Structs</h4>\n<p>모듈의 이름이 곧 맵타입이 됨. 딕셔너리 기능이 없으므로 키값이 반드시 아톰이어야 한다.\n구조체는 구조체에 특정한 행위를 정의하기위해 모듈 안에 정의한다.\n구조체 안에 구조체를 넣는 Nested Structs 구현이 가능하다. Nested Struct의 접근자(Nested Accessor)는 기본적으로 컴파일 타임에 동작하는 매크로인데, 컴파일 타임에 동작하면 static하게 기능할 수 밖에 없으므로 다이나믹하게  </p>\n<h3 id=\"엘릭서에서의-타입이란\"><a href=\"#%EC%97%98%EB%A6%AD%EC%84%9C%EC%97%90%EC%84%9C%EC%9D%98-%ED%83%80%EC%9E%85%EC%9D%B4%EB%9E%80\" aria-label=\"엘릭서에서의 타입이란 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>엘릭서에서의 타입이란?</h3>\n<p>primitive type vs functionality of module\nIn my mind, there’s a difference between the primitive list and the functional- ity of the List module. The primitive list is an implementation, whereas the List module adds a layer of abstraction.\n-> 엘릭서의 원시타입은 구현체이며, 모듈은 원시타입 구현체에 추상레이어를 추가한 것이다.\n-> 가령 Map은 원시타입이지만, keyword 타입을 통해 딕셔너리 튜플 리스트 형태로 표현할 수 있다. 이 경우, 리스트에서 제공하는 풍부한 모듈을 함께 사용할 수 있다.</p>","timeToRead":1,"excerpt":"리스트와 재귀 Heads and Tails 엘릭서는 join operator인 파이프 연산자로 머리와 나머지(tail…","frontmatter":{"title":"Programming Elixir 4 - 타입과 모듈","cover":"","date":"2020-01-28T10:59:24.000Z","categories":["Elixir"],"tags":["elixir","type","module"]},"fields":{"slug":"/programming-elixir-4-타입과-모듈","date":"January 27, 2020"}}},"pageContext":{"slug":"/programming-elixir-4-타입과-모듈","nexttitle":"Programming Elixir 3 - 함수","nextslug":"/programming-elixir-3-함수","prevtitle":"Programming Elixir 5 - 콜렉션 처리","prevslug":"/programming-elixir-5-콜렉션-처리"}}}