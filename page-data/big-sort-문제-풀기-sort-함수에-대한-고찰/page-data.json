{"componentChunkName":"component---src-templates-post-js","path":"/big-sort-문제-풀기-sort-함수에-대한-고찰","result":{"data":{"markdownRemark":{"html":"<p>hackerrank에서 string으로 이루어진 무작위 순서의 리스트를 정렬하는 <a href=\"https://www.hackerrank.com/challenges/big-sorting/\">big-sorting</a>문제를 풀었다. 내장된 sort()함수를 쓰면 안될 것 같아 직접 선택정렬을 활용한 sort함수를 구현했는데 케이스 절반만 통과했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">bigSorting</span><span class=\"token punctuation\">(</span>unsorted<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>unsorted<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        lgidx<span class=\"token punctuation\">,</span> largest <span class=\"token operator\">=</span> i<span class=\"token punctuation\">,</span> unsorted<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n        j <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span>\n        <span class=\"token keyword\">while</span> i<span class=\"token operator\">+</span>j <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>unsorted<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>largest<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># 자릿수가 다르면 바로 순서 변경</span>\n                lgidx <span class=\"token operator\">=</span> j<span class=\"token operator\">+</span>i\n                largest <span class=\"token operator\">=</span> unsorted<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span>i<span class=\"token punctuation\">]</span>\n            <span class=\"token keyword\">elif</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>unsorted<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>largest<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\"># 자릿수가 같으면 숫자로 캐스팅한 다음 비교</span>\n                <span class=\"token keyword\">if</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>unsorted<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>largest<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                    lgidx <span class=\"token operator\">=</span> j<span class=\"token operator\">+</span>i\n                    largest <span class=\"token operator\">=</span> unsorted<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span>i<span class=\"token punctuation\">]</span>\n            j<span class=\"token operator\">-=</span><span class=\"token number\">1</span>\n        <span class=\"token keyword\">if</span> unsorted<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> largest<span class=\"token punctuation\">:</span>\n            temp <span class=\"token operator\">=</span> unsorted<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n            unsorted<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> largest\n            unsorted<span class=\"token punctuation\">[</span>lgidx<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp\n    <span class=\"token keyword\">return</span> unsorted</code></pre></div>\n<p>이 문제의 핵심은 string에서 int로 캐스팅할때 발생하는 비용처리이다. 내 코드는 자릿수가 다른 경우만 처리한다는 점, 그리고 선택정렬 자체가 효율적이지 못했던 점이 문제였던 것 같다. 꽤 오랜시간을 들였는데도 답이 나오지 않아서 discussion을 읽기 시작했는데, 알지 못했던 사실들이 많았다.</p>\n<h3 id=\"sort는-꽤-훌륭한-구현속도를-자랑하며-sorted와-성능상-큰-차이가-없다\"><a href=\"#sort%EB%8A%94-%EA%BD%A4-%ED%9B%8C%EB%A5%AD%ED%95%9C-%EA%B5%AC%ED%98%84%EC%86%8D%EB%8F%84%EB%A5%BC-%EC%9E%90%EB%9E%91%ED%95%98%EB%A9%B0-sorted%EC%99%80-%EC%84%B1%EB%8A%A5%EC%83%81-%ED%81%B0-%EC%B0%A8%EC%9D%B4%EA%B0%80-%EC%97%86%EB%8B%A4\" aria-label=\"sort는 꽤 훌륭한 구현속도를 자랑하며 sorted와 성능상 큰 차이가 없다 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>sort()는 꽤 훌륭한 구현속도를 자랑하며, sorted()와 성능상 큰 차이가 없다.</h3>\n<p>sort()만 사용해도 테스트 케이스는 3문제를 제외하고(숫자 대소 확인이 안되어서 wrong answer가 된다) 모두 통과한다. 정렬은 둘 중 어느 함수를 써도 상관없다. 차이라면 sort()는 배열 원본의 순서를 변경하지만 sorted는 정렬된 리스트를 반환한다는 점이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">arr<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ncopy_arr <span class=\"token operator\">=</span> <span class=\"token builtin\">sorted</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span></code></pre></div>\n<h3 id=\"int에서-string으로-캐스팅할-때-비용이-반대의-경우보다-훨씬-크다\"><a href=\"#int%EC%97%90%EC%84%9C-string%EC%9C%BC%EB%A1%9C-%EC%BA%90%EC%8A%A4%ED%8C%85%ED%95%A0-%EB%95%8C-%EB%B9%84%EC%9A%A9%EC%9D%B4-%EB%B0%98%EB%8C%80%EC%9D%98-%EA%B2%BD%EC%9A%B0%EB%B3%B4%EB%8B%A4-%ED%9B%A8%EC%94%AC-%ED%81%AC%EB%8B%A4\" aria-label=\"int에서 string으로 캐스팅할 때 비용이 반대의 경우보다 훨씬 크다 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>int에서 string으로 캐스팅할 때 비용이 반대의 경우보다 훨씬 크다.</h3>\n<p>big sorting 문제풀이를 하려면 비교를 위해 필연적으로 string을 int로 변환하고, print구문으로 출력을 위해 string으로 변환하는 과정을 거친다. 여기서 숫자간 대소비교를 위해 int캐스팅 하는 과정은 비교적 빠르게 이루어지지만, 비교를 위해 변경한 int값을 string으로 바꾸는것은 꽤 오래걸린다.</p>\n<h3 id=\"해법-sortkeyint\"><a href=\"#%ED%95%B4%EB%B2%95-sortkeyint\" aria-label=\"해법 sortkeyint permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>해법: sort(key=int)</h3>\n<p>결론적으로 캐스팅 과정을 최소화 해야하는데, 3.6의 sort함수는 비교를 위한 키값을 파라미터로 받는다. 즉, key값으로 int를 지정해주면 정렬의 대소비교를 위해서만 캐스팅을 하고, 본래의 원소는 string으로 정렬된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">arr<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span>key<span class=\"token operator\">=</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span>\ncopy_arr <span class=\"token operator\">=</span> <span class=\"token builtin\">sorted</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> key<span class=\"token operator\">=</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h3 id=\"더-좋은-해결-sortkeylen\"><a href=\"#%EB%8D%94-%EC%A2%8B%EC%9D%80-%ED%95%B4%EA%B2%B0-sortkeylen\" aria-label=\"더 좋은 해결 sortkeylen permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>더 좋은 해결!: sort(key=len)</h3>\n<p>하지만 위의 경우도 여전히 캐스팅은 발생한다. 캐스팅 없이 정렬할때의 문제는 숫자 대소인데, string기준으로 sorting을 한 다음에 key값으로 int가 아니라 문자열의 길이로 한번 더 sorting 해주면 통과할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">arr <span class=\"token operator\">=</span> <span class=\"token builtin\">sorted</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">sorted</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> key<span class=\"token operator\">=</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>그러나 이건 제출의 문제이고, key값에 비교 람다함수를 넣어서 한번의 정렬만 일어나게 하면 훨씬 빠르게 연산이 일어난다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> timeit\n<span class=\"token keyword\">def</span> <span class=\"token function\">bigSortinglen</span><span class=\"token punctuation\">(</span>unsorted<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">return</span> <span class=\"token builtin\">sorted</span><span class=\"token punctuation\">(</span>unsorted<span class=\"token punctuation\">,</span> key<span class=\"token operator\">=</span><span class=\"token keyword\">lambda</span> x<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">bigSortingint</span><span class=\"token punctuation\">(</span>unsorted<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">return</span> <span class=\"token builtin\">sorted</span><span class=\"token punctuation\">(</span>unsorted<span class=\"token punctuation\">,</span> key<span class=\"token operator\">=</span><span class=\"token keyword\">lambda</span> x<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"bigSorting - len:\"</span><span class=\"token punctuation\">,</span>\n    timeit<span class=\"token punctuation\">.</span>timeit<span class=\"token punctuation\">(</span><span class=\"token string\">\"bigSortinglen(unsorted)\"</span><span class=\"token punctuation\">,</span> \n    <span class=\"token builtin\">globals</span><span class=\"token operator\">=</span><span class=\"token builtin\">globals</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n    number<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"bigSorting - int:\"</span><span class=\"token punctuation\">,</span>\n    timeit<span class=\"token punctuation\">.</span>timeit<span class=\"token punctuation\">(</span><span class=\"token string\">\"bigSortingint(unsorted)\"</span><span class=\"token punctuation\">,</span> \n    <span class=\"token builtin\">globals</span><span class=\"token operator\">=</span><span class=\"token builtin\">globals</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> \n    number<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p>실제로 timeit 라이브러리를 통해 시간을 비교하면 550배나 더 빠르다는 것을 알 수 있다.\n<code class=\"language-text\">bigSorting - len: 0.007199285000751843</code>\n<code class=\"language-text\">bigSorting - int: 3.989389060998292</code></p>","timeToRead":3,"excerpt":"hackerrank에서 string으로 이루어진 무작위 순서의 리스트를 정렬하는 big-sorting문제를 풀었다. 내장된 sort()함수를 쓰면 안될 것 같아 직접 선택정렬을 활용한 sort…","frontmatter":{"title":"big sort 문제 풀기 - sort()함수에 대한 고찰","cover":"","date":"2019-07-21T16:29:01.000Z","categories":["Phython"],"tags":["python","algorithm"]},"fields":{"slug":"/big-sort-문제-풀기-sort-함수에-대한-고찰","date":"July 20, 2019"}}},"pageContext":{"slug":"/big-sort-문제-풀기-sort-함수에-대한-고찰","nexttitle":"윈도우 파워쉘 권한 변경하기","nextslug":"/윈도우-파워쉘-권한-변경하기","prevtitle":"ASP.NET Core nuget package 배포하기","prevslug":"/asp-net-core-nuget-package-배포하기"}}}