{"componentChunkName":"component---src-templates-post-js","path":"/c-기본서-bcl-thread-monitor-lock-interlocked","result":{"data":{"markdownRemark":{"html":"<h3 id=\"thread-context\"><a href=\"#thread-context\" aria-label=\"thread context permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Thread Context</h3>\n<ul>\n<li>스레드는 CPU의 명령어 실행과 관련된 정보를 보관한다. 이를 스레드 문맥이라고 한다.</li>\n<li>즉, 언제 실행하고 또 이전에 얼만큼 실행했는지를 기억하는 것이다.</li>\n<li>초기에는 단일 CPU였기 떄문에 다중스레드는 1개의 CPU에서 조금씩 실행시간을 나누어 실행하는 형태였지만</li>\n<li>멀티 CPU/Core시대가 오면서 진정한 다중 스레드 실행이 가능해졌다</li>\n</ul>\n<h3 id=\"스레드-제대로-이해하기-systemthreadingthread\"><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-systemthreadingthread\" aria-label=\"스레드 제대로 이해하기 systemthreadingthread permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스레드 제대로 이해하기: System.Threading.Thread</h3>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">static voic Main(string[] args) {\n    Thread t = new Thread(threadFunc);\n    t.background = true;\n    t.start(); \n}\nstatic void ThreadFunc() {\n    Console.WriteLine(&quot;60초 후 종료&quot;);\n    Thread.Sleep(1000*60);\n    Console.WriteLine(&quot;종료&quot;);\n}</code></pre></div>\n<ul>\n<li>위의 코드를 보면 t는 배경 스레드이기때문에 메인스레드 실행과 무관하게 실행된다. 때문에 콘솔이 찍히지 않거나 아주 낮은확률로 첫번째 콘솔라인만 찍히게 된다.</li>\n<li>여기서 backgroud옵션을 제거하고 실행하면 전경스레드(foreground thread)에 속하게 되므로 스레드 실행 종료 후에 메인스레드가 종료된다.</li>\n<li>스레드에 인자를 넘길 수 있다. (436p~)</li>\n</ul>\n<h3 id=\"다중스레드에서의-공유-자원-관리-systemthreadingmonitor\"><a href=\"#%EB%8B%A4%EC%A4%91%EC%8A%A4%EB%A0%88%EB%93%9C%EC%97%90%EC%84%9C%EC%9D%98-%EA%B3%B5%EC%9C%A0-%EC%9E%90%EC%9B%90-%EA%B4%80%EB%A6%AC-systemthreadingmonitor\" aria-label=\"다중스레드에서의 공유 자원 관리 systemthreadingmonitor permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다중스레드에서의 공유 자원 관리: System.Threading.Monitor</h3>\n<ul>\n<li>\n<p>한개의 스레드에 할당된 스택의 용량은 1MB이며, 메모리가 허용하는한 원하는만큼 생성할 수 있다.</p>\n<ul>\n<li>가령 32비트 윈도우에서 32비트 프로세스는 2GB메모리가 허용되므로, 오직 스레드에만 메모리가 사용된다고 가정해도 2000개를 넘을 수 없다.</li>\n<li>그러나 64비트 시대가 열리면서 tera바이트 단위로 메모리 할당이 가능해져 스레드 갯수의 제한이 풀렸다봐도 무방하다.</li>\n</ul>\n</li>\n<li>\n<p>코드상 여러개의 스레드를 동시의 실행시키면 그 실행순서는 담보할 수 없다.</p>\n<ul>\n<li>이 경우 '공유 리소스 동기화' 문제가 생긴다. </li>\n<li>\n<p>이를 해소하기위한 BCL 제공 클래스가 Monitor이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">static void ThreadFunc(object inst) {\nProgram pg = inst as Program;\nfor(int i=0; i&lt;100000; i++) {\nMonitor.Enter(pg);\ntry {\n    pg.number = pg.number + 1;\n} finally {\n    Monitor.Exit(pg);\n    //Enter와 Exit 코드 사이에 위치한 모든 코드는 스레드 하나만 진입해서 실행할 수 있다. 즉, 해당 코드가 한 스레드에 의해 점유된 상태면 다른 스레드는 대기상태가 된다.\n}\n}\n}</code></pre></div>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"다중스레드에서의-공유-자원-관리-lock\"><a href=\"#%EB%8B%A4%EC%A4%91%EC%8A%A4%EB%A0%88%EB%93%9C%EC%97%90%EC%84%9C%EC%9D%98-%EA%B3%B5%EC%9C%A0-%EC%9E%90%EC%9B%90-%EA%B4%80%EB%A6%AC-lock\" aria-label=\"다중스레드에서의 공유 자원 관리 lock permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다중스레드에서의 공유 자원 관리: lock</h3>\n<ul>\n<li>\n<p>C#은 Monitor와 동일하지만 더 간결한 lock예약어를 제공한다. 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">static void ThreadFunc(object inst) {\nProgram pg = inst as Program;\nfor(int i=0; i&lt;100000; i++) {\n    Monitor.Enter(pg);\n    lock(pg)\n    {\n        pg.number = pg.number + 1;\n    }\n}\n}</code></pre></div>\n</li>\n<li>\n<p>lock이나 Monitor를 사용하지 않는 객체 인스턴스 사용은 thread-safe하지 않다고 한다. MSDN은 BCL 도움말에서 타입별 메서드의 스레드 안정성을 명시하고 있다.</p>\n<ul>\n<li>가령 ArrayList타입의 정적멤버는 다중 스레드 접근에 안전하지만 인스턴스는 안전하지 않다고 명시한다.</li>\n<li>그럼 전부 thread safe하게 만들면 되지 않나 할 수 있지만 그럼 성능이 나지 않는다!</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"다중스레드에서의-공유-자원-관리-interlocked\"><a href=\"#%EB%8B%A4%EC%A4%91%EC%8A%A4%EB%A0%88%EB%93%9C%EC%97%90%EC%84%9C%EC%9D%98-%EA%B3%B5%EC%9C%A0-%EC%9E%90%EC%9B%90-%EA%B4%80%EB%A6%AC-interlocked\" aria-label=\"다중스레드에서의 공유 자원 관리 interlocked permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다중스레드에서의 공유 자원 관리: interlocked</h3>\n<ul>\n<li>BCL은 다중 스레드에서의 공유자원을 사용하는 몇몇 패턴에 대해 정적메서드를 제공한다.</li>\n<li>\n<p>가령 32/64비트 숫자 타입의 일부 연산은 interlocked를 통해 처리할 수 있다</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">class MyData {\nint number = 0;\npublic int Number {get {return number;}}\npublic void Increment() {\n    Interlocked.Increment(ref number);\n}\n}</code></pre></div>\n</li>\n<li>위와 같은 연산을 원자적인 연산, 즉 쪼갤수 없는 단일한 연산이라고 할 수 있는데, 이는 프로그래밍적인 의미에서 비트 연산을 생각하면 된다.</li>\n<li>\n<p>가령 32비트 운영체제에서 int64 변수에 5를 할당하면 아래와같이 연산을 한다.</p>\n<ol>\n<li>하위 32비트에 0x00000000를 쓰고</li>\n<li>상위 32비트에 0x05000000를 쓴다 *16비트 연산의 경우 <a href=\"http://webcreate.tistory.com/entry/16%EB%B9%84%ED%8A%B8-32%EB%B9%84%ED%8A%B8-%EB%B9%84%ED%8A%B8%EC%97%B0%EC%82%B0-%EB%B0%A9%EB%B2%95\">참고</a></li>\n</ol>\n</li>\n</ul>\n<h3 id=\"스레드-효율적으로-쓰기-systemthreadingthreadpool\"><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%93%B0%EA%B8%B0-systemthreadingthreadpool\" aria-label=\"스레드 효율적으로 쓰기 systemthreadingthreadpool permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스레드 효율적으로 쓰기: System.Threading.ThreadPool</h3>\n<ul>\n<li>특정스레드를 연산만 하고 바로 종료하는 경우, 효율적으로 사용하기 위해서 ThreadPool이 제공된다</li>\n<li>\n<p>ThreadPool을 사용해서 스레드를 실행하면 메서드를 실행한 스레드는 바로 종료되지 않고 일정시간 보관된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">static void Main(string[] args) {\nMyData data = new MyData();\nThreadPool.QueueUserWorkItem(threadFunc, data);\nThreadPool.QueueUserWorkItem(threadFunc, data);\nThread.Sleep(1000);\n}</code></pre></div>\n</li>\n</ul>\n<h3 id=\"스레드간-동기화-systemthreadingeventwaithandle\"><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C%EA%B0%84-%EB%8F%99%EA%B8%B0%ED%99%94-systemthreadingeventwaithandle\" aria-label=\"스레드간 동기화 systemthreadingeventwaithandle permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스레드간 동기화: System.Threading.EventWaitHandle</h3>\n<ul>\n<li>EventWaitHandle은 Monitor처럼 스레드간 동기화 수단중 하나라고 보면 된다</li>\n<li>\n<p>스레드간 non-signal &#x3C;--> signal 상태별로 할 액션을 지정해주며 동기화 처리를 한다</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">static void Main(string[] args) {\nEventWaitHandle ewh = new EventWaitHandle (false, EventResetMode.ManualReset)\n}</code></pre></div>\n</li>\n</ul>","timeToRead":4,"excerpt":"Thread Context 스레드는 CPU의 명령어 실행과 관련된 정보를 보관한다. 이를 스레드 문맥이라고 한다. 즉, 언제 실행하고 또 이전에 얼만큼 실행했는지를 기억하는 것이다. 초기에는 단일 CPU였기 떄문에 다중스레드는 1개의 CPU…","frontmatter":{"title":"c# 기본서 - BCL: Thread, Monitor, Lock, Interlocked","cover":"","date":"2018-11-27T00:14:00.000Z","categories":["C#"],"tags":["c#","bcl","thread","monitor","lock","interlocked"]},"fields":{"slug":"/c-기본서-bcl-thread-monitor-lock-interlocked","date":"November 26, 2018"}}},"pageContext":{"slug":"/c-기본서-bcl-thread-monitor-lock-interlocked","nexttitle":"c# 기본서 - BCL: File, Direcotry, Path","nextslug":"/c-기본서-bcl-file-direcotry-path","prevtitle":"c# 기본서 - BCL: 비동기 호출","prevslug":"/c-기본서-bcl-비동기-호출"}}}