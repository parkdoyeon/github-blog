{"componentChunkName":"component---src-templates-post-js","path":"/programming-elixir-5-콜렉션-처리","result":{"data":{"markdownRemark":{"html":"<h3 id=\"enum\"><a href=\"#enum\" aria-label=\"enum permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Enum</h3>\n<p>Enum은 엘릭서의 모든 콜렉션 타입을 다루는 workhorse이다.\n그러나 데이터 변환작업시 메모리에 중간 결과물을 포함한 모든 콜렉션 데이터를 올려놓기 때문에 lazy하게 동작하도록 하려면 Stream을 사용해야한다.\nStream은 스트림간의 모든 함수와 호환된다. 따라서 Stream은 Composable하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">IO.puts File.open!(“/usr/share/dict/words”)\n             |&gt; IO.stream(:line)\n             |&gt; Enum.max_by(&amp;String.length/1)\n\n# 위 코드의 shortcut코드\nIO.puts File.stream!(“/usr/share/dict/words”)\n             |&gt; Enum.max_by(&amp;String.length/1)\n\n# Stream을 사용한 구현은 중간 storage가 없는 대신 두배 이상 느리다는 단점이 있지만,\n# 데이터가 도달하면 바로바로 처리된다는 장점이 있다.\n# 가령 Enum으로만 구현한 경우 연속된 스트림라인이 늦게 도달했을 때 처리가 훨씬 더 오래걸릴 수 있다.</code></pre></div>\n<h3 id=\"collectable-protocol\"><a href=\"#collectable-protocol\" aria-label=\"collectable protocol permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Collectable Protocol</h3>\n<p>Enumerable Protocol은 타입 안의 요소를 순회하는 것이라면, Collectable은 반대의 개념으로 요소를 더해서 Collection을 빌드한다.\n그러나 모든 콜렉션이 collectable한것은 아니다. Range 타입의 경우 요소 추가가 불가능 하며, Enum을 통한 Collectable 타입의 전환을 통해서 요소 추가가 가능하다. 이때, 이미 데이터가 있는 리스트와 병합되는 경우 range가 리스트 tail에 붙는다</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">iex&gt; Enum.into 1..5, [100, 101]\n[100, 101, 1, 2, 3, 4, 5]</code></pre></div>\n<h3 id=\"comprehension-works-on-bits-too\"><a href=\"#comprehension-works-on-bits-too\" aria-label=\"comprehension works on bits too permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Comprehension Works on Bits, Too</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">iex&gt; for &lt;&lt; &lt;&lt; b1::size(2), b2::size(3), b3::size(3) &gt;&gt; &lt;- “hello” &gt;&gt; , do: “0#{b1}#{b2}#{b3}”\n[&quot;0150&quot;, &quot;0145&quot;, &quot;0154&quot;, &quot;0154&quot;, &quot;0157”]</code></pre></div>\n<p>여기서 &#x3C;&#x3C;>>은 바이너리를 가리킨다</p>\n<h3 id=\"moving-past-divinity\"><a href=\"#moving-past-divinity\" aria-label=\"moving past divinity permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Moving Past Divinity</h3>\n<p>엘릭서를 효율적으로 학습하는 과정의 일부는 재귀와 순회를 적재적소에 사용하는 것을 고민하는 것이다.\n가능하면 순회를 사용할 것을 권장한다.</p>","timeToRead":1,"excerpt":"Enum Enum은 엘릭서의 모든 콜렉션 타입을 다루는 workhorse이다.\n그러나 데이터 변환작업시 메모리에 중간 결과물을 포함한 모든 콜렉션 데이터를 올려놓기 때문에 lazy하게 동작하도록 하려면 Stream을 사용해야한다.\nStream…","frontmatter":{"title":"Programming Elixir 5 - 콜렉션 처리","cover":"","date":"2020-01-29T11:01:04.000Z","categories":["Elixir"],"tags":["elixir","enum","collection"]},"fields":{"slug":"/programming-elixir-5-콜렉션-처리","date":"January 28, 2020"}}},"pageContext":{"slug":"/programming-elixir-5-콜렉션-처리","nexttitle":"Programming Elixir 4 - 타입과 모듈","nextslug":"/programming-elixir-4-타입과-모듈","prevtitle":"Programming Elixir 6 - 문자열, 제어흐름","prevslug":"/programming-elixir-6-문자열-제어흐름"}}}