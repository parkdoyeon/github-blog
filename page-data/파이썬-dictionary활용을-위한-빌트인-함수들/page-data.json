{"componentChunkName":"component---src-templates-post-js","path":"/파이썬-dictionary활용을-위한-빌트인-함수들","result":{"data":{"markdownRemark":{"html":"<p>DB를 잘 쓰려면 쿼리를 알아야 하듯이, 알고리즘 문제를 풀다보면 정확한 자료형을 구현하기위해선 빌트인 함수를 잘 써야한다. 가령 아래 배열에서 같은 인덱스 값을 갖는 값들이 어떤 곡의 장르와 플레이 횟수라고 했을때, 장르별 플레이 횟수 합산을 하고, 횟수 단위로 순위를 매기려면 어떻게 해야할까?</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">genres <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"classic\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"pop\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"classic\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"classic\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"pop\"</span><span class=\"token punctuation\">]</span>\nplays <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">500</span><span class=\"token punctuation\">,</span> <span class=\"token number\">600</span><span class=\"token punctuation\">,</span> <span class=\"token number\">150</span><span class=\"token punctuation\">,</span> <span class=\"token number\">500</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2500</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>코드적으로 의미를 해석하면, 장르별 데이터라면 2개의 값이 서로 key-value관계를 가지며, 특정 장르별로 합산이 되어야한다는 것은 중복되지 않는 key값 단위로 합산이 이루어진다는 것을 의미한다. 이것을 순서로 정리하면</p>\n<ol>\n<li>해당 key값을 갖는 딕셔너리를 생성한 다음에</li>\n<li>연산을 위해 0을 value로 할당하고 </li>\n<li>순회하면서 더하고</li>\n<li>\n<p>순위를 매긴다.\n단순해보이지만 여기까지도 다양한 선택지가 존재한다. 여기 동일한 로직을 적용했지만 코드가 다른 두개의 방법이 있다. </p>\n<h3 id=\"방법-1-fromkeys로-딕셔너리-생성후-index를-직접-순회하며-더하기\"><a href=\"#%EB%B0%A9%EB%B2%95-1-fromkeys%EB%A1%9C-%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC-%EC%83%9D%EC%84%B1%ED%9B%84-index%EB%A5%BC-%EC%A7%81%EC%A0%91-%EC%88%9C%ED%9A%8C%ED%95%98%EB%A9%B0-%EB%8D%94%ED%95%98%EA%B8%B0\" aria-label=\"방법 1 fromkeys로 딕셔너리 생성후 index를 직접 순회하며 더하기 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>방법 1: fromkeys로 딕셔너리 생성후 index를 직접 순회하며 더하기</h3>\n<p>fromkeys는 순회가능한 리스트를 key값으로 생성한 딕셔너리를 만든다. 주의할점은 두번째 파라미터값으로 초기값을 받는데, 여기에 list()를 할당하면 <strong>같은 주소값을 갖는다.</strong> 즉, 해당 value값의 변형이 일어나면 <strong><em>모든 key에 대응하는 list값이 영향을 받는다.</em></strong> 때문에 list할당시에는 comprehension이나 아래에 defaultdict()함수를 사용해야한다. fromkeys르 딕셔너리 생성후, genres와 plays는 서로 같은 인덱스에 대응하하므로 직접 인덱스 값을 순회하며 플레이 횟수를 더해준다. 합산된 딕셔너리는 다시 순서값이 있는 데이터형인 tuple자료형으로 변환된 다음, sort()로 정렬된다. 2차원 이상의 자료형은 제일 앞의 인자를 기준으로 sort된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">genre_rank_dict <span class=\"token operator\">=</span> <span class=\"token builtin\">dict</span><span class=\"token punctuation\">.</span>fromkeys<span class=\"token punctuation\">(</span>genres<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 딕셔너리 생성</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>plays<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\ngenre_rank_dict<span class=\"token punctuation\">[</span>genres<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> plays<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span></code></pre></div>\n</li>\n</ol>\n<p>genre<em>rank = [(albumrank[g], g) for g in albumrank.keys()]\ngenre</em>rank.sort(reverse=True)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">### 방법 2: defaultdict으로 생성하고 zip으로 순회하기\n두번째 바법은 defaultdict으로 빈 딕셔너리를 생성하는데, 람다함수로 초기값을 지정할 수 있다. 초기값을 지정해놓으면 함수연산이 바로 가능하다는 장점이 있다. 딕셔너리 생성 후에는 tuple자료형으로 장르와 재생횟수를 묶어서 dictionary에 넣어준다. zip은 iterable 오브젝트이기 때문에, 위의 방식과 성능적으로 전혀 차이가 없지만 더 명확하고 깔끔한 코드를 작성할 수 있는 장점이 있다. dict자료형이 완성되면 아래도 마찬가지로 items()함수를 호출해 tuple형으로 바꿔주는데, 컴프리헨션을 통해 플레이 휫수 기준으로 정렬된 tuple 리스트에서 장르만 순서대로 빼놓은 리스트를 새로 생성한다.\n``` python\ngenre_rank_dict = defaultdict(lambda: 0) # 딕셔너리 생성\nfor genre, play in zip(genres, plays):\n    genre_rank_dict[genre] += play\n\ngenre_rank = [genre for genre, play in sorted(genre_play_dict.items(), key=itemgetter(1), reverse=True)]</code></pre></div>","timeToRead":2,"excerpt":"DB…","frontmatter":{"title":"파이썬 dictionary활용을 위한 빌트인 함수들","cover":"","date":"2019-07-24T01:03:58.000Z","categories":["Phython"],"tags":["python","algorithm","dictionary"]},"fields":{"slug":"/파이썬-dictionary활용을-위한-빌트인-함수들","date":"July 23, 2019"}}},"pageContext":{"slug":"/파이썬-dictionary활용을-위한-빌트인-함수들","nexttitle":"ASP.NET Core nuget package 배포하기","nextslug":"/asp-net-core-nuget-package-배포하기","prevtitle":"파이썬 sort()함수 key 파라미터 제대로 사용하기","prevslug":"/파이썬-sort-함수-key-파라미터-제대로-사용하기"}}}