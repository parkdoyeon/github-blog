{"componentChunkName":"component---src-templates-post-js","path":"/programming-elixir-1-원리","result":{"data":{"markdownRemark":{"html":"<h3 id=\"확장자-convention\"><a href=\"#%ED%99%95%EC%9E%A5%EC%9E%90-convention\" aria-label=\"확장자 convention permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>확장자 convention</h3>\n<p><code class=\"language-text\">.ex</code></p>\n<ul>\n<li>바이트코드로 컴파일 되고 실행됨</li>\n<li>바이너리 파일로 컴파일 해야할때 사용하는 확장자</li>\n<li>프로그램 어플리케이션으로 사용됨</li>\n</ul>\n<p><code class=\"language-text\">.exs</code></p>\n<ul>\n<li>컴파일 없이 쓰는 스크립트 프로그램</li>\n<li>소스레벨에서 interpret됨</li>\n<li>보통 테스트 코드에 사용</li>\n</ul>\n<h3 id=\"elixir-asserts-variable-not-assigns\"><a href=\"#elixir-asserts-variable-not-assigns\" aria-label=\"elixir asserts variable not assigns permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Elixir asserts variable, not assigns.</h3>\n<p>엘릭서는 변수를 merge 하듯이 사용한다. 하지만 이미 값이 부여된 변수의 경우 그 값을 보관하기때문에(variables bind once per match), 이와 다른 값(value)과 매치하면 매치에러가 발생한다. 다시말해, 엘릭서에서의 ‘=' 수학에서의 수식과 유사한 의미를 갖는다. 프로그래밍을 하면서 제일 먼저 버리게되는 등호에 대한 직관을 다시 되찾아옴. (하지만 왼쪽 항에서 계산연산을 하지는 않음)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">iex&gt; a = 1\n1\nies&gt; 1 = a\n1\nIex&gt; 2 = a\n** (MatchError) no match of right hand side value: 1</code></pre></div>\n<p>2와 a는 매치되지 않으므로 매치에러 발생</p>\n<p>엘릭서는 \"Fail early”하는 것이 reliable한 코드 작성을 위한 방법이다. 때문에 아래와 같은 패턴이 자주 사용된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{ :ok, file } = File.open(“/etc/passwd”)</code></pre></div>\n<p>성공하면 file에 객체가 담기겠지만 그렇지 않으면 :error가 리턴되면서 MatchError 익셉션이 발생할 것이다.\n패턴매칭, 파이프 오퍼레이터를 사용하면 </p>\n<h3 id=\"variables-bind-once-per-match\"><a href=\"#variables-bind-once-per-match\" aria-label=\"variables bind once per match permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>variables bind once per match</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">iex&gt; [a, a] = [1, 1]\n[1, 1]\niex&gt; a\n1\niex&gt; [b, b] = [1, 2]\n** (MatchError) no match of right hand side value: [1, 2]\niex&gt; [a, a] = [2, 2]\n# 새로운 매치이기 때문에 에러발생 안함</code></pre></div>\n<p>Force existing value\n기존 값을 고수하고싶다면 캐럿(caret)마크로 표기한다. 기존 값이 아닌 다른 값이 매치되면 Exception이 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Iex&gt; a = 1\n1\niex&gt; [^a, 2, 3] = [8, 2, 3]\nMatchError </code></pre></div>\n<h3 id=\"immutability\"><a href=\"#immutability\" aria-label=\"immutability permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Immutability</h3>\n<p>일반 언어는 기존 데이터를 통해 새로운 데이터를 생성할때 기존 데이터가 “변할 수도 있기”때문에 복제본을 생성한다.\n그러나 엘릭서의 모든 값은 변하지 않는다는 약속이 지켜지므로, 원본 데이터의 단순 참조를 통해 새로운 데이터를 생성할 수도 있다. 무척 효율적.</p>\n<h3 id=\"gc\"><a href=\"#gc\" aria-label=\"gc permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GC</h3>\n<p>엘릭서는 여러 프로세스에서 실행되기 때문에 각 프로세스별로 힙이 생성되고, 프로세스가 종료되면 바로 힙을 날리기 때문에 gc가 무척 빠르게 돌아간다. 때문에 기존 언어에서 사용되지 않은 오래된 값이 메모리를 잡고 있는 문제를 해소한다.</p>","timeToRead":2,"excerpt":"확장자 convention  바이트코드로 컴파일 되고 실행됨 바이너리 파일로 컴파일 해야할때 사용하는 확장자 프로그램 어플리케이션으로 사용됨  컴파일 없이 쓰는 스크립트 프로그램 소스레벨에서 interpret됨 보통 테스트 코드에 사용 Elixir…","frontmatter":{"title":"Programming Elixir 1 - 원리","cover":"","date":"2020-01-23T10:48:16.000Z","categories":["Elixir"],"tags":["elixir"]},"fields":{"slug":"/programming-elixir-1-원리","date":"January 22, 2020"}}},"pageContext":{"slug":"/programming-elixir-1-원리","nexttitle":"리눅스 도커 lftp로 파일 배포하기","nextslug":"/리눅스-도커-lftp로-파일-배포하기","prevtitle":"Programming Elixir 2 - 자료형과 오퍼레이터","prevslug":"/programming-elixir-2-자료형과-오퍼레이터"}}}