{"componentChunkName":"component---src-templates-post-js","path":"/c-기본서-빌드환경과-gc-힙과-스택","result":{"data":{"markdownRemark":{"html":"<h3 id=\"전처리기-지시문-if-endif\"><a href=\"#%EC%A0%84%EC%B2%98%EB%A6%AC%EA%B8%B0-%EC%A7%80%EC%8B%9C%EB%AC%B8-if-endif\" aria-label=\"전처리기 지시문 if endif permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>전처리기 지시문 #if #endif</h3>\n<ul>\n<li>잔처리기를 사용하면 컴파일시 적용되는 구문을 분기처리할 수 있다.</li>\n<li>DEBUG와 TRACE상수의 경우 빌드 옵션에서 세팅할수 있고, 별도로 세팅을 하고싶으면 <a href=\"https://stackoverflow.com/questions/507704/will-if-release-work-like-if-debug-does-in-c\">아래대로 하면</a> 된다</li>\n<li>Project Properties -> Build</li>\n<li>Select Release Mode</li>\n<li>in the Conditional compilation symbols textbox enter: RELEASE</li>\n<li>이 밖에도 #warning, #error, #line, #region, #endregion, #pragma 등이 있다.</li>\n</ul>\n<h3 id=\"attribute\"><a href=\"#attribute\" aria-label=\"attribute permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[Attribute]</h3>\n<ul>\n<li>개발자로하여금 컴파일 후에도 EXE/DLL파일에 남길 수 있는 주석처럼 사용되는 코드</li>\n<li>라고는 하는데 우리팀은 캐싱이나 인증 로직을 조건처럼 구현할때 사용했다.</li>\n<li>직접 특성(Attribute)을 만들수도있는데, System.Attribute를 상속받으면 된다</li>\n<li>특성을 적용받는 타겟을 옵션으로 줄 수도 있다.</li>\n<li>참조: [Conditional(\"DEBUG\")] 이렇게 입력하면 전처리기지시문처럼 해당 함수를 DEBUG때만 빌드하게 할 수 있다.</li>\n</ul>\n<h3 id=\"예약어-checked-unchecked\"><a href=\"#%EC%98%88%EC%95%BD%EC%96%B4-checked-unchecked\" aria-label=\"예약어 checked unchecked permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>예약어 checked, unchecked</h3>\n<ul>\n<li>산술 범위가 넘어가면서 중요한 수치가 되는 값들이 증발하는 경우(overflow/underflow)를 막기위해 사용된다</li>\n<li>checked 블록을 만들고 연산을 수행하면 예외를던지고</li>\n<li>checked옵션을 전체 적용하고 unchecked블록을 생성하면 해당 블록 내에서 over/underflow가 일어나도 예외가 나타나지 않는다</li>\n</ul>\n<h3 id=\"가변-매개변수-params\"><a href=\"#%EA%B0%80%EB%B3%80-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-params\" aria-label=\"가변 매개변수 params permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가변 매개변수 params</h3>\n<ul>\n<li>\n<p>파라미터가 여러개가 될수도 있을 때 아래와같이 표기하면 다양하게 값을 넣을 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">static int Add(params int[] args)\n{\n//연산\n}\nstatic void DoSomething(params object[] args)\n{\n//연산\n}</code></pre></div>\n</li>\n</ul>\n<h3 id=\"빌드-구성요소-dll-appconfig\"><a href=\"#%EB%B9%8C%EB%93%9C-%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C-dll-appconfig\" aria-label=\"빌드 구성요소 dll appconfig permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>빌드 구성요소: dll, app.config</h3>\n<ul>\n<li>dll파일을 위한 함수는 public으로 만든다</li>\n<li>한 dll에 여러 프로세스가 접근할 수 있다</li>\n<li>그러나 프로세스별로 동일 dll의 다른 버전을 요구할수도 있다. 이때는 공개키토큰이나 어셈블리 서명방식을 통해 구분할 수 있다.</li>\n<li>app.config는 개발자 코드 실행전 단계인 CLR환경 초기화에사 어떤 값을 전달해야할때 사용되는 변수/설정사항 등을 선언해놓는 곳이다</li>\n<li>app.config를 통해 프레임워크를 설정할 수 있다. 닷넷프레임워크는 4.0이후부터 업데이트시 파일이 대체되므로 구버전을 설치한 경우 이전 버전들이 남아있다.</li>\n<li>\n<p>MS는 타입과 타입이 정의된 어셈블리를 느낌표로 구분한다</p>\n<ul>\n<li>ex) mscorlib.dll에 구현된 System.Object의 경우 -> mscorlib!System.Object</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"릴리즈와-디버깅모드\"><a href=\"#%EB%A6%B4%EB%A6%AC%EC%A6%88%EC%99%80-%EB%94%94%EB%B2%84%EA%B9%85%EB%AA%A8%EB%93%9C\" aria-label=\"릴리즈와 디버깅모드 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>릴리즈와 디버깅모드</h3>\n<ul>\n<li>Release의경우 코드최적화를 하기때문에 StackTrace로 남는 내용이 정확하게 보여지지 않을 수 있다.</li>\n<li>Trace는 Debug와 달리 릴리즈모드에도 실행된다. 즉 추적을 위한 네임스페이스이다.</li>\n</ul>\n<h3 id=\"플랫폼-선택-anycpu-x86-x64\"><a href=\"#%ED%94%8C%EB%9E%AB%ED%8F%BC-%EC%84%A0%ED%83%9D-anycpu-x86-x64\" aria-label=\"플랫폼 선택 anycpu x86 x64 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>플랫폼 선택 (AnyCPU, x86, x64)</h3>\n<ul>\n<li>일단 AnyCPU를 사용할것을 권장.</li>\n<li>x86은 어느윈도우든 32비트exe로 실행되고</li>\n<li>x64는 64비트 윈도우에서 64비트exe로만 실행된다. 32비트 윈도우에선 실행 되지 않는다.</li>\n<li>AnyCPU인 경우는 각 비트에 맞게 실행된다. 다만 오직 AnyCpu에서만 옵션을 통해 32비트 기본사용을 선택할 수 있다.</li>\n<li>32비트 기본사용 옵션이 필요한 이유는 32비트exe인 dll이 매우 많기 때문. 가령 ActiveX </li>\n</ul>\n<h3 id=\"예외처리와-자원수거\"><a href=\"#%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC%EC%99%80-%EC%9E%90%EC%9B%90%EC%88%98%EA%B1%B0\" aria-label=\"예외처리와 자원수거 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>예외처리와 자원수거</h3>\n<ul>\n<li>\n<p>finally가 필요한 이유는 예외가 발생해도 db나 file은 자원수거는 해야하기떄문</p>\n<ul>\n<li>자원수거를 자연스럽게 하는 또다른 방법은 using이 있다.</li>\n<li>개발자의 실수를 예방하고 방어적인 차원에서 해제코드를 넣는 것이 소멸자. 해제코드가 언제 실행될지는 모르기때문에 사용은 하지 말자.</li>\n</ul>\n</li>\n<li>throw는 단독으로 사용하는게 좋다. throw ex를 하면 예외시점부터의 스택이 호출된다.</li>\n</ul>\n<h3 id=\"스택\"><a href=\"#%EC%8A%A4%ED%83%9D\" aria-label=\"스택 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스택</h3>\n<ul>\n<li>힙과 스택 둘 다 데이터를 위한 메모리이다.</li>\n<li>스택은 스레드 생성이 되면 기본적으로 1mb용량으로 할당된다.</li>\n<li>스택은 메서드의 실행, 메서드 인자, 지역변수를 처리한다. 떄문에 재귀호출로인한 에러는 스택오버플로우이다.</li>\n<li>스택 에러발생시 메모리가 모두 소비되었기 때문에 StackTrace를 알려주는 메서드 호출이 불가하다</li>\n</ul>\n<h3 id=\"힙\"><a href=\"#%ED%9E%99\" aria-label=\"힙 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>힙</h3>\n<ul>\n<li>CLR에서는 기본적으로 관리힙을 가리킨다. GC의 할당, 해지를 관리한다</li>\n<li>new로 할당되는 모든 참조형 객체는 힙에 할당된다. 얘넨 모두 GC가 직접 관리한다.</li>\n<li>박싱 언박싱은 참조형데이터와 값데이터간의 이동을 의미하는데, 박싱이 일어날경우 값데이터를 참조형으로 변경하게 되므로 GC가 매우 바빠진다. 대표적인 예가 값데이터를 함수의 인자로 넣는 경우.</li>\n<li>대용량 객체 힙(Large Object Heap)이 있다. 가비지 수집마다 LOH를 이동시키는건 부담이 크므로 GC가 직접 관리하지 않는다.</li>\n</ul>\n<h3 id=\"gc\"><a href=\"#gc\" aria-label=\"gc permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GC</h3>\n<ul>\n<li>CLR의 세대는 2세대가 끝이다.</li>\n</ul>","timeToRead":3,"excerpt":"전처리기 지시문 #if #endif 잔처리기를 사용하면 컴파일시 적용되는 구문을 분기처리할 수 있다. DEBUG와 TRACE상수의 경우 빌드 옵션에서 세팅할수 있고, 별도로 세팅을 하고싶으면 아래대로 하면 된다 Project Properties…","frontmatter":{"title":"c# 기본서 - 빌드환경과 GC, 힙과 스택","cover":"","date":"2018-11-06T23:10:00.000Z","categories":["C#"],"tags":["c#","build","GC","Stack","Heap","Attribute","예약어","dll","자원수거"]},"fields":{"slug":"/c-기본서-빌드환경과-gc-힙과-스택","date":"November 05, 2018"}}},"pageContext":{"slug":"/c-기본서-빌드환경과-gc-힙과-스택","nexttitle":"Logstash - 파이프라인 만들기","nextslug":"/logstash-파이프라인-만들기","prevtitle":"c# 기본서 - BCL: 시간계산, Collection, 문자열처리, 직렬화와 Stream","prevslug":"/c-기본서-bcl-시간계산-collection-문자열처리-직렬화와-stream"}}}